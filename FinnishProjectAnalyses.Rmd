---
title: "FinnishDataProject"
author: "Sergio Vela Moreno"
date: "2024-05-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Data loading:

```{r}
setwd("C:/Users/sergio.vela/Desktop/FinnishProject")
getwd()=="C:/Users/sergio.vela/Desktop/FinnishProject"
```

```{r}
library(readr)

DatasetRiskOfRecurrence <- read.csv("DataRiskOfRecurrenceFinnishCohort.csv")

DatasetRiskOfRecurrence <- DatasetRiskOfRecurrence[,-33]
```

```{r}
NAsVector <- vector()

for (i in 1:NCOL(DatasetRiskOfRecurrence)) {
  if (NROW (DatasetRiskOfRecurrence %>% 
            dplyr::filter(DatasetRiskOfRecurrence[i] != "NA")) / NROW(DatasetRiskOfRecurrence) < 0.7) {
    print(i)
    NAsVector <- append(NAsVector,i)
  }
}
```

```{r}
DatasetRiskOfRecurrenceTP53MMRd <- DatasetRiskOfRecurrence[,-c(1,4,34)]

DatasetRiskOfRecurrenceTraditional <- DatasetRiskOfRecurrence[,-c(1,31,32,34)]

DatasetRiskOfRecurrenceESGO <- DatasetRiskOfRecurrence[,-c(4,31,32,34)]

DatasetRiskOfRecurrencePOLE <- DatasetRiskOfRecurrence[,-c(1,4,31,32)]

#write.csv(DatasetRiskOfRecurrenceTP53MMRd, "DatasetTP53MMRdRiskOfRecurrence.csv", row.names = FALSE)
#write.csv(DatasetRiskOfRecurrenceTraditional, "DatasetTraditionalRiskOfRecurrence.csv", row.names = FALSE)
#write.csv(DatasetRiskOfRecurrenceESGO, "DatasetESGORiskOfRecurrence.csv", row.names = FALSE)
#write.csv(DatasetRiskOfRecurrencePOLE, "DatasetPOLERiskOfRecurrence.csv", row.names = FALSE)
```

#### Applied molecular distribution:

This creates a barplot showing the Molecular Distribution of the cohort

```{r}
library(ggplot2)

AppliedMolecularDistribution <- ggplot(DatasetRiskOfRecurrenceTraditional, mapping = aes(x = DatasetRiskOfRecurrenceTraditional$AppliedMolecularClassification)) +
  geom_bar(mapping = aes(fill = DatasetRiskOfRecurrenceTraditional$AppliedMolecularClassification)) + scale_fill_discrete(name = "Molecular subtype") + ggtitle("Molecular distribution of samples") +
  xlab("Subtype") + ylab("Count") + theme_bw() +
   geom_text(aes(label = ..count..), stat = "count", vjust = 2, colour = "white")

### RUN TOGETHER:
png("AppliedMolecularDistribution.png") 
# 2. Create a plot
plot(AppliedMolecularDistribution)
# Close the png file
dev.off() 
### UNTIL HERE

### RUN TOGETHER:
pdf("AppliedMolecularDistribution.pdf") 
# 2. Create a plot
plot(AppliedMolecularDistribution)
# Close the pdf file
dev.off() 
### UNTIL HERE
```

### Demographics tables:

The following table created the demographics table shown in Table 2 of the manuscript. There is a small variation to it, as missing values are reported
in the figure foot instead of whithin the table.

```{r}
library(tidyverse)
library(finalfit)
library(randomForest)
library(dplyr)

DatasetRiskOfRecurrence <- read.csv("DataRiskOfRecurrenceFinnishCohort.csv")

DatasetRiskOfRecurrence <- DatasetRiskOfRecurrence%>%   #Ensure that all the character-type features are changed to factors
  mutate(across(where(is.character), as.factor))

DatasetRiskOfRecurrence <- droplevels(DatasetRiskOfRecurrence)

explanatory <- c("MolecularESGOESTROESP2021", "AppliedMolecularClassification", "p53ab", "MMRd", "POLE", "StageIvsIItoIV",  "HistologyandGrade", "LVSI", "MyometrialInvasion","cytology", "TumorSize","DiabetesMellitus", "BMI", "Age", "Smoker", "ASAScore", "Thrombocyte", "Leucocyte", "Haemoglobin","Ca125","PDL1intensity", "TILPDL1to10","ARID1AIHC", "EstrogenReceptor1", "ProgesteroneRececeptor","HER2", "betacatenin",  "HNFβ", "P16", "Ecadherin", "vimentin", "CD171pn")

DemographicTableRecurRisk <-  DatasetRiskOfRecurrence %>% 
  summary_factorlist("RecurrenceRisk", explanatory,
                     p=TRUE, na_include=TRUE)

DemographicTableRecurRisk

#writexl::write_xlsx(DemograficTableRecurRisk, "DemographicTableRelapseRisk.xlsx") #This saves the Demographic table (Table 2) as an Excel file
```

### Recursive feature elimination: 
#### TP53 + MMRd rfe with tidymodels:

```{r}
# install.packages(c("tidymodels", "vip", "themis")) #If not previously available

library(tidymodels)
library(vip)
library(themis)
library(readr)
library(caret)
library(dplyr)
library(randomForest)

#DatasetRiskOfRecurrenceTP53MMRd <- read_csv("DatasetTP53MMRdRiskOfRecurrence.csv")

DatasetRiskOfRecurrenceTP53MMRd <- DatasetRiskOfRecurrenceTP53MMRd %>%
  dplyr::select(!Time)      #Remove time feature as it is not required in this part and it should not be included in the RFE

DatasetRiskOfRecurrenceTP53MMRd <- DatasetRiskOfRecurrenceTP53MMRd%>%
  mutate(across(where(is.character), as.factor))

FirstRecipe <- recipe(`RecurrenceRisk` ~ ., data =DatasetRiskOfRecurrenceTP53MMRd) %>%
  step_dummy(all_nominal_predictors())            # Transforms factor features to dummies
    
set.seed(123)
split <- initial_split(DatasetRiskOfRecurrenceTP53MMRd, prop = 0.7, strata = `RecurrenceRisk`)
datos_train <- training(split)
datos_testValidation  <- testing(split)

split2 <- initial_split(datos_testValidation, prop = 0.7, strata = `RecurrenceRisk`)

datos_test <- training(split2)
datos_Validation  <- testing(split2)

# Make sure that the character features are factors after partitioning the dataset

datos_train <- datos_train %>%
  mutate(across(where(is.character), as.factor))

datos_test <- datos_test %>%
  mutate(across(where(is.character), as.factor))

datos_Validation <- datos_Validation %>%
  mutate(across(where(is.character), as.factor))

datos_train <- datos_train %>%       #Renaming outcome feature for clarity
  rename(recurrence_risk = `RecurrenceRisk`)

datos_test <- datos_test %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_Validation <- datos_Validation %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_train$recurrence_risk <- factor(datos_train$recurrence_risk)    #Ensure that the levels order is the same, otherwise this overwrites them. If it's not, you can use relevel to set the reference level

datos_test$recurrence_risk <- factor(datos_test$recurrence_risk, levels = levels(datos_train$recurrence_risk))

datos_Validation$recurrence_risk <- factor(datos_Validation$recurrence_risk, levels = levels(datos_train$recurrence_risk))

datos_train <- na.roughfix(datos_train) #Imputation after partition of the dataset

datos_test <- na.roughfix(datos_test)

datos_Validation <- na.roughfix(datos_Validation)

base_recipe <- recipe(recurrence_risk ~ ., data = datos_train) %>%
  step_zv(all_predictors()) %>%                      # Eliminates predictors without variation
  step_normalize(all_numeric_predictors()) %>%    # Standardizes numeric covariates
  step_dummy(all_nominal_predictors())            # Transforms factor features to dummies. This was already done before partition, so it should not change anything

base_recipe_prepared <- prep(base_recipe, training = datos_train, retain = TRUE)

processed_data <- juice(base_recipe_prepared)    #Preprocessed data is extracted and used to train a ranger model

model_rf <- rand_forest(mode = "classification", trees = 500) %>%
  set_engine("ranger", importance = "impurity")

model_base <- model_rf %>%
  fit(recurrence_risk ~ ., data = processed_data)

vip_vals <- model_base %>% vi()

sorted_variables <- vip_vals %>%   #Obtain the list of features sorted by higher to lowwer importance
  arrange(desc(Importance)) %>%
  pull(Variable)

# 5 fold cross-validation for RFE:   #Beginning of cross-validated RFE to get the best subset of features
cv_folds <- vfold_cv(datos_train, v = 5, strata = recurrence_risk)

evaluate_with_top_n <- function(n) {
  print(n)
  n_local <- n
  top_vars <- sorted_variables[1:n_local]
  top_vars <- union(top_vars, "recurrence_risk")
  
  recipe_rfe <- recipe(recurrence_risk ~ ., data = datos_train) %>%
    step_zv(all_predictors()) %>%
    step_normalize(all_numeric_predictors()) %>%
    step_dummy(all_nominal_predictors()) %>%
    step_smote(recurrence_risk) %>%
    step_select(all_of(top_vars))
  
  wf <- workflow() %>%
    add_model(model_rf) %>%
    add_recipe(recipe_rfe) 

  res <- fit_resamples(
    wf,
    resamples = cv_folds,
    metrics = metric_set(accuracy, f_meas, kap, roc_auc, pr_auc),
    control = control_resamples(save_pred = TRUE)
  )
  
  collect_metrics(res) %>%
    mutate(num_vars = n_local)
}

top_n_values <- c(5:30)

results_rfe <- map_dfr(top_n_values, evaluate_with_top_n)   #Run the RFE function with different number of features

#saveRDS(results_rfe, "RFEresultsTP53MMRd.rds")
#saveRDS(sorted_variables, "MoreToleastImportantFeaturesTP53MMRd.rds")
#write.csv(results_rfe, "RFEresultsTP53MMRd.csv")

#results_rfe <- readRDS("RFEresultsTP53MMRd.rds")
#sorted_variables <- readRDS("MoreToleastImportantFeaturesTP53MMRd.rds")

best_n <- results_rfe %>%      #Extract which is the best number of features (according to F1-Score results)
  filter(.metric == "f_meas") %>%
  arrange(desc(mean)) %>%
  slice(1) %>%
  pull(num_vars)

cat("Best number of features according to F1-score:", best_n, "\n") 

best_vars <- sorted_variables[1:19]

best_vars <- setdiff(best_vars, "recurrence_risk")

recipe_final <- recipe(recurrence_risk ~ ., data = datos_train) %>%    #Get a recipe that selects the subset of best features obtained
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>%
  update_role(recurrence_risk, new_role = "outcome") %>%
  step_select(all_of(best_vars), starts_with("recurrence_risk")) %>%
  step_smote(recurrence_risk, skip = TRUE)

prep(recipe_final, training = datos_train) %>% juice() %>% names() %>% any(. == "recurrence_risk")

wf_final <- workflow() %>%
  add_model(modelo_rf) %>%
  add_recipe(receta_final)

fit_final <- fit(
  wf_final,
  data = datos_train)

recipe_eval <- recipe_final %>% prep(training = datos_train, retain = TRUE) #Preprocess the train data with the recipe
datos_train_bake <- bake(recipe_eval, new_data = datos_train) #Obtain train and test data processed and with the optimal subset of features
datos_test_bake <- bake(recipe_eval, new_data = datos_test)

fit_final %>% extract_fit_parsnip() %>% .$fit %>% names()
```


### Algorithms training for TP53 + MMRd models:
#### Training with GBM:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 810 
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(10000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels <- datos_train_bake

levels(opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk) <- c("NoRelapse", "EarlyRelapse", "LateRelpase")

opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels <- droplevels(opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels)

opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels <- datos_test_bake

levels(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk) <- c("NoRelapse", "EarlyRelapse", "LateRelpase")

opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels <- droplevels(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels)

gbmGrid <-  expand.grid(interaction.depth = c(1, 5, 9), 
                        n.trees = (1:30)*50, 
                        shrinkage = c(0.01,0.05,0.1),
                        n.minobsinnode = c(5,10,20))
```

```{r}
set.seed(123)
TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels,
                            method="gbm",
                            trControl=fitControl,
                            verbose=FALSE,
                            tuneGrid = gbmGrid,
                            metric='AUC')

TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels

ic_f1  <- quantile(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$F1, c(.025, .975), na.rm = TRUE)
ic_auc <- quantile(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$AUC, c(.025, .975), na.rm = TRUE)
ic_sen <- quantile(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Sensitivity, c(.025, .975), na.rm = TRUE)
ic_acc <- quantile(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Accuracy, c(.025, .975), na.rm = TRUE)

#saveRDS(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, file = "TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthF1Tidymodels.rds")

#TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthF1Tidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

#### Rf:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 19 
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
rfGrid <-  expand.grid(mtry = (1:19))

set.seed(123)
TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels,
                            method="rf",
                            verbose = FALSE,
                            tuneGrid = rfGrid,
                            trControl=fitControl,
                            metric='AUC')

TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels


#saveRDS(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, file = "TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")

TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

#### KNN:

```{r}
knn_grid <- expand.grid(k = seq(3, 21, by = 2)) 
```

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 10 
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
set.seed(123)
TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels,
                            method="knn",
                            verbose = FALSE,
                            trControl=fitControl,
                            metric='AUC',
                            tuneGrid = knn_grid)

TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels

#saveRDS(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, file = "TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")

#TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TP53MMRdRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

#### SVM:

```{r}
svm_grid <- expand.grid(
  C = 2^(-1:2),
  sigma = 2^(-2:1)
)
n_models <- nrow(svm_grid)  # 16 combinations

set.seed(123)
num_folds <- 100 
seeds <- vector(mode = "list", length = num_folds + 1)
for (i in 1:num_folds) {
  seeds[[i]] <- sample.int(1000, n_models)
}

seeds[[num_folds + 1]] <- sample.int(1000, 1)

fitControlSVM <- trainControl(
  method = "repeatedcv",
  number = 10,
  repeats = 10,
  seeds = seeds,
  returnResamp = "final",
  search = "grid",
  verboseIter = FALSE,
  allowParallel = TRUE,
  classProbs = TRUE,
  summaryFunction = metrics_mlmetrics,
  sampling = "smote" 
)
```

```{r}
set.seed(123)
TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels,
                            method="svmRadial",
                            trControl=fitControlSVM  ,
                            metric='AUC',
                            tuneGrid = svm_grid)

TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels

#saveRDS(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, file = "TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")

#TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Train.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TP53MMRdRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
```

### Metrics extraction per class and figures creation:

```{r}
library(caret)
library(yardstick)
library(dplyr)
library(ggplot2)
library(tibble)
library(purrr)

predictionstidymodels <- predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels)

real_classTidymodels <- factor(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)
predictionstidymodels <- factor(predictionstidymodels, levels = levels(clase_realTidymodels))
probs_tidymodels <- predict(
  TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,
  opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels,
  type = "prob"
)

df_resultsTidymodels <- tibble(
  truth = real_classTidymodels,
  predicted = factor(predictionstidymodels,levels = levels(real_classTidymodels))
) %>%
  bind_cols(probs_tidymodels)

classesTidymodels <- levels(real_classTidymodels)

library(rlang)  

calculate_metrics_per_classTidymodels <- function(class_objetive) {
  df_binary <- df_resultsTidymodels %>%
    mutate(
      truth_bin = factor(ifelse(truth == class_objetive, "Yes", "No"), levels = c("Yes", "No")),
      pred_bin  = factor(ifelse(predicted == class_objetive, "Yes", "No"), levels = c("Yes", "No"))
    )
  
   precision <- yardstick::precision(data = df_binary, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  recall    <- yardstick::recall(data = df_binary, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  f1        <- yardstick::f_meas(data = df_binary, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  Accuracy_specific        <- yardstick::accuracy(data = df_binary, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  roc_auc_auc <- roc_auc(df_binary, truth_bin, !!sym(class_objetive), event_level = "first")$.estimate
  pr_auc_auc  <- pr_auc(df_binary, truth_bin, !!sym(class_objetive), event_level = "first")$.estimate
    
   tibble(
    Class = class_objetive,
    Metric = c("Precision", "Recall", "F1-score", "Accuracy","ROC AUC", "PR AUC"),
    Value = c(precision, recall, f1, Accuracy_specific, roc_auc_auc, pr_auc_auc)
  )
}

results_per_classTidymodels <- map_dfr(classesTidymodels, calculate_metrics_per_classTidymodels)

print("Metrics per class:")
print(results_per_classTidymodels)

ggplot(results_per_classTidymodels, aes(x = Metric, y = Value, fill = Metric)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~Class) +
  ylim(0, 1) +
  labs(
    title = "Metrics per class",
    x = "Metric",
    y = "Value"
  ) +
  theme_minimal(base_size = 8)
```

#### Creation of ROC AUC and PR AUC plots:

```{r}
library(pROC)

result.predicted.prob <- predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels
,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels, type="prob") # Prediction

result.roc <- roc(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk, result.predicted.prob$EarlyRelapse) # Draw ROC curve.
plot(result.roc, print.thres="best", print.thres.best.method="closest.topleft")

result.coords <- coords(result.roc, "best", best.method="closest.topleft", ret=c("threshold", "accuracy"))
print(result.coords)#to get threshold and accuracy

result.auc <- multiclass.roc(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk, result.predicted.prob) # Draw ROC curve.

AUCplotTP53MMRdRiskRecur <-
  par(pty = "s")
plot.roc(result.auc$rocs$`EarlyRelapse/LateRelpase`[[1]], 
         print.auc=T,
         legacy.axes = T)
plot.roc(result.auc$rocs$`EarlyRelapse/NoRelapse`[[1]],
         add=T, col = 'red',
         print.auc = T,
         legacy.axes = T,
         print.auc.adj = c(0,3))
plot.roc(result.auc$rocs$`LateRelpase/NoRelapse`[[1]],add=T, col = 'blue',
         print.auc=T,
         legacy.axes = T,
         print.auc.adj = c(0,5))

legend('bottomright',
       legend = c('EarlyRelapse/LateRelpase',
                  'EarlyRelapse/NoRelapse',
                  'LateRelpase/NoRelapse'),cex=0.75,
       col=c('black','red','blue'),lwd=2)

AUCplotTP53MMRdRiskRecur
```

#### SHAP figures creation:

```{r}
library(kernelshap)
library(shapviz)

sRFFinnishRecurTP53MMRdTidymodels <- kernelshap(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, X = opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels[,-20], bg_X = opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels, type = "prob")

svFinnishRecurTP53MMRdTidymodels <- shapviz(sRFFinnishRecurTP53MMRdTidymodels)

FeatureImportanceTP53MMRdTidymodels <- sv_importance(svFinnishRecurTP53MMRdTidymodels, kind = "bar",bar_type = "stack" , max_display = 10) + ylab("Feature") + xlab("Average absolute SHAP values") + theme(axis.text.y = element_text(size = 6),axis.text.x = element_text(size = 6))  

FeatureImportanceTP53MMRdTidymodels

#saveRDS(sRFFinnishRecurTP53MMRdTidymodels, "sRFFinnishRecurTP53MMRdTidymodels.rds")
#saveRDS(FeatureImportanceTP53MMRdTidymodels, "FeatureImportanceTP53MMRdTidymodels.rds")

FeatureImportanceTP53MMRdTidymodels <- readRDS("FeatureImportanceTP53MMRdTidymodels.rds")
```

```{r}
library(gbm)
ImportanceFinnishRecurTP53MMRdTidymodels <- varImp(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROC, scale = FALSE)

ImportanceFinnishRecurTP53MMRdTidymodels <- ImportanceFinnishRecurTP53MMRdTidymodels$importance

ImportanceFinnishRecurTP53MMRdTidymodels <- cbind(ImportanceFinnishRecurTP53MMRdTidymodels, row.names(ImportanceFinnishRecurTP53MMRdTidymodels))
```

```{r}
ImportanceFinnishRecurTP53MMRdTidymodelsSorted <- ImportanceFinnishRecurTP53MMRdTidymodels[order(ImportanceFinnishRecurTP53MMRdTidymodels$Overall, decreasing = TRUE),]
```

### Traditional - rfe with tidymodels:

```{r}
# install.packages(c("tidymodels", "vip", "themis"))

library(tidymodels)
library(vip)
library(themis)

library(readr)
#DatasetRiskOfRecurrenceTraditional <- read_csv("DatasetTraditionalRiskOfRecurrence.csv")

DatasetRiskOfRecurrenceTraditional <- DatasetRiskOfRecurrenceTraditional %>%
  dplyr::select(!Time)  

DatasetRiskOfRecurrenceTraditional <- DatasetRiskOfRecurrenceTraditional%>%
  mutate(across(where(is.character), as.factor))

recipeTraditional <- recipe(`RecurrenceRisk` ~ ., data =DatasetRiskOfRecurrenceTraditional) %>%   
  step_dummy(all_nominal_predictors())            
    
set.seed(123)
splitTraditional <- initial_split(DatasetRiskOfRecurrenceTraditional, prop = 0.7, strata = `RecurrenceRisk`)
datos_trainTraditional <- training(splitTraditional)
datos_testValidationTraditional  <- testing(splitTraditional)

splitTraditional2 <- initial_split(datos_testValidationTraditional, prop = 0.7, strata = `RecurrenceRisk`)
datos_testTraditional <- training(splitTraditional2)
datos_ValidationTraditional  <- testing(splitTraditional2)

datos_trainTraditional <- datos_trainTraditional %>%
  mutate(across(where(is.character), as.factor))

datos_testTraditional <- datos_testTraditional %>%
  mutate(across(where(is.character), as.factor))

datos_ValidationTraditional <- datos_ValidationTraditional %>%
  mutate(across(where(is.character), as.factor))

datos_trainTraditional <- datos_trainTraditional %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_testTraditional <- datos_testTraditional %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_ValidationTraditional <- datos_ValidationTraditional %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_trainTraditional$recurrence_risk <- factor(datos_trainTraditional$recurrence_risk)

datos_testTraditional$recurrence_risk <- factor(datos_testTraditional$recurrence_risk, levels = levels(datos_trainTraditional$recurrence_risk))

datos_ValidationTraditional$recurrence_risk <- factor(datos_ValidationTraditional$recurrence_risk, levels = levels(datos_trainTraditional$recurrence_risk))

datos_trainTraditional <- na.roughfix(datos_trainTraditional)

datos_testTraditional <- na.roughfix(datos_testTraditional)

datos_ValidationTraditional <- na.roughfix(datos_ValidationTraditional)

base_recipe_Traditional <- recipe(recurrence_risk ~ ., data = datos_trainTraditional) %>%
  step_zv(all_predictors()) %>%                    
  step_normalize(all_numeric_predictors()) %>%    
  step_dummy(all_nominal_predictors())            

base_recipe_preparedTraditional <- prep(base_recipe_Traditional, training = datos_trainTraditional, retain = TRUE)

preprocessed_dataTraditional <- juice(base_recipe_preparedTraditional)

model_rfTraditional <- rand_forest(mode = "classification", trees = 500) %>%
  set_engine("ranger", importance = "impurity")

model_baseTraditional <- model_rfTraditional %>%
  fit(recurrence_risk ~ ., data = preprocessed_dataTraditional)

vip_valsTraditional <- model_baseTraditional %>% vi()

sorted_variablesTraditional <- vip_valsTraditional %>%
  arrange(desc(Importance)) %>%
  pull(Variable)

cv_foldsTraditional <- vfold_cv(datos_trainTraditional, v = 5, strata = recurrence_risk)

evaluate_with_top_nTraditional <- function(n) {
  print(n)
  n_local <- n
  top_varsTraditional <- sorted_variablesTraditional[1:n_local]
  top_varsTraditional <- union(top_varsTraditional, "recurrence_risk")
    
  recipe_rfeTraditional <- recipe(recurrence_risk ~ ., data = datos_trainTraditional) %>%
    step_zv(all_predictors()) %>%
    step_normalize(all_numeric_predictors()) %>%
    step_dummy(all_nominal_predictors()) %>%
    step_smote(recurrence_risk) %>%
    step_select(all_of(top_varsTraditional))
  
  wfTraditional <- workflow() %>%
    add_model(model_rfTraditional) %>%
    add_recipe(recipe_rfeTraditional)  

  resTraditional <- fit_resamples(
    wfTraditional,
    resamples = cv_foldsTraditional,
    metrics = metric_set(accuracy, f_meas, kap, roc_auc, pr_auc),
    control = control_resamples(save_pred = TRUE)
  )
  
  collect_metrics(resTraditional) %>%
    mutate(num_vars = n_local)
}

top_n_values <- c(5:30)

results_rfeTraditional <- map_dfr(top_n_values, evaluate_with_top_nTraditional)

#saveRDS(results_rfeTraditional, "RFEresultsTraditional.rds")
#saveRDS(sorted_variablesTraditional, "MoreToleastImportantFeaturesTraditional.rds")
#write.csv(results_rfeTraditional, "RFEresultsTraditional.csv")

results_rfeTraditional <- readRDS("RFEresultsTraditional.rds")
sorted_variablesTraditional <- readRDS("MoreToleastImportantFeaturesTraditional.rds")

Best_nTraditional <- results_rfeTraditional %>%
  filter(.metric == "f_meas") %>%
  arrange(desc(mean)) %>%
  slice(1) %>%
  pull(num_vars)

cat("Best number of features according to F1-score:", Best_nTraditional, "\n") 

#### Stability calculation:
n_top_stability <- 20  

obtain_topN_per_foldTraditional <- function(split, n_top = n_top_stability) {
  
  df_train_fold <- analysis(split)
  
  recipe_fold <- recipe(recurrence_risk ~ ., data = df_train_fold) %>%
    step_zv(all_predictors()) %>%
    step_normalize(all_numeric_predictors()) %>%
    step_dummy(all_nominal_predictors())
  
  recipe_fold_prep <- prep(recipe_fold, training = df_train_fold, retain = TRUE)
  df_proc_fold <- juice(recipe_fold_prep)
  
  model_fold <- model_rfTraditional %>%
    fit(recurrence_risk ~ ., data = df_proc_fold)
  
  vip_fold <- model_fold %>% vi()
  
  sorted_variables_fold <- vip_fold %>%
    arrange(desc(Importance)) %>%
    pull(Variable)
  
  tibble(variable = sorted_variables_fold[1:n_top])
}

vars_per_foldTraditional <- cv_foldsTraditional$splits %>%
  map_dfr(
    ~ obtain_topN_per_foldTraditional(.x),
    .id = "fold"
  )

stability_per_foldTraditional <- vars_per_foldTraditional %>%
  count(variable, name = "freq") %>%
  mutate(
    stability = freq / length(cv_foldsTraditional$splits)
  ) %>%
  arrange(desc(stability))

stability_per_foldTraditional

stability_per_foldTraditional <- stability_per_foldTraditional %>%
  mutate(variable = recode(variable,
                          "MyometrialInvasion" = "Myometrial Invasion",
                          "Ca125"  = "Ca125",
                          "StageIvsIItoIV_StageII.IV" = "Stage I vs II-IV",
                          "Leucocyte" = "Leucocyte",
                          "BMI" = "BMI",
                          "Thrombocyte" = "Thrombocyte",
                          "Age" = "Age",
                          "Haemoglobin" = "Hemoglobin",
                          "cytology_Positive" = "Positive cytology",
                          "HistologyandGrade_non.endometrioid" = "Non endometrioid",
                          "LVSI_Yes" = "LVSI",
                          "ProgesteroneRececeptor_POS...10.." = "PR",
                          "Ecadherin_normal" = "Normal Ecadherin",
                          "EstrogenReceptor1_ER.under.1." = "ER",
                          "ASAScore" = "ASA Score",
                          "Ecadherin_weakened" = "Weakened Ecadherin",
                          "ARID1AIHC_Positive" = "ARID1A",
                          "DiabetesMellitus_Yes" = "Diabetic",
                          "TumorSize_X.25mm" = "Tumor size",
                          "CD171pn_Positive" = "CD171",
                          "vimentin_Positive" = "Positive vimentin",
                          "HistologyandGrade_endometrioid.G3" = "Endometrioid G3",
                          "betacatenin_Positive" = "Positive betacatenin"))

#write.csv(stability_per_foldTraditional, "RFEstabilityPerFold.csv") #This is Supplementary table 3
```

```{r}
library(tidyverse)

# Create a matrix with fold × variable to represent in a figure
matrix_fold_variableTraditional <- vars_per_foldTraditional %>%
  mutate(selection = 1) %>%
  pivot_wider(
    names_from = variable,
    values_from = selection,
    values_fill = 0
  )

matrix_fold_variableTraditional

library(ggplot2)

matrix_longTraditional <- matrix_fold_variableTraditional %>%
  pivot_longer(
    cols = -fold,
    names_to = "variable",
    values_to = "selection"
  )

unique(matrix_longTraditional$variable)

matrix_longTraditional <- matrix_longTraditional %>%
  mutate(variable = recode(variable,
                          "MyometrialInvasion" = "Myometrial Invasion",
                          "Ca125"  = "Ca125",
                          "StageIvsIItoIV_StageII.IV" = "Stage I vs II-IV",
                          "Leucocyte" = "Leucocyte",
                          "BMI" = "BMI",
                          "Thrombocyte" = "Thrombocyte",
                          "Age" = "Age",
                          "Haemoglobin" = "Hemoglobin",
                          "cytology_Positive" = "Positive cytology",
                          "HistologyandGrade_non.endometrioid" = "Non endometrioid",
                          "LVSI_Yes" = "LVSI",
                          "ProgesteroneRececeptor_POS...10.." = "PR",
                          "Ecadherin_normal" = "Normal Ecadherin",
                          "EstrogenReceptor1_ER.under.1." = "ER",
                          "ASAScore" = "ASA Score",
                          "Ecadherin_weakened" = "Weakened Ecadherin",
                          "ARID1AIHC_Positive" = "ARID1A",
                          "DiabetesMellitus_Yes" = "Diabetic",
                          "TumorSize_X.25mm" = "Tumor size",
                          "CD171pn_Positive" = "CD171",
                          "vimentin_Positive" = "Positive vimentin",
                          "HistologyandGrade_endometrioid.G3" = "Endometrioid G3",
                          "betacatenin_Positive" = "Positive betacatenin"))
```


```{r}
#Create the heatmap for RFE stability (Supplementary Figure 2)
FeatureSelectionHeatmap <- ggplot(matrix_longTraditional,
       aes(x = variable, y = fold, fill = selection)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  labs(
    title = NULL,
    x = "Feature",
    y = "Fold",
    fill = "Selected"
  )

FeatureSelectionHeatmap

### RUN TOGETHER:
pdf("FeatureSelectionHeatmap.pdf") 
# 2. Create a plot
plot(FeatureSelectionHeatmap)
# Close the pdf file
dev.off() 
### Hasta aqui


### RUN TOGETHER:
png("FeatureSelectionHeatmap.png") 
# 2. Create a plot
plot(FeatureSelectionHeatmap)
# Close the pdf file
dev.off() 
### Hasta aqui

FeatureSelectionHeatmap
```

Best_varsTraditional <- sorted_variablesTraditional[1:22]

Best_varsTraditional <- setdiff(Best_varsTraditional, "recurrence_risk")

recipe_finalTraditional <- recipe(recurrence_risk ~ ., data = datos_trainTraditional) %>%
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>%
  update_role(recurrence_risk, new_role = "outcome") %>%
  step_select(all_of(Best_varsTraditional), starts_with("recurrence_risk")) %>%
  step_smote(recurrence_risk, skip = TRUE)

prep(recipe_finalTraditional, training = datos_trainTraditional) %>% juice() %>% names() %>% any(. == "recurrence_risk")

wf_finalTraditional <- workflow() %>%
  add_model(model_rfTraditional) %>%
  add_recipe(recipe_finalTraditional)

fit_finalTraditional <- fit(
  wf_finalTraditional,
  data = datos_trainTraditional)

recipe_evalTraditional <- recipe_finalTraditional %>% prep(training = datos_trainTraditional, retain = TRUE)
datos_train_bakeTraditional <- bake(receta_evalTraditional, new_data = datos_trainTraditional)
datos_test_bakeTraditional <- bake(receta_evalTraditional, new_data = datos_testTraditional)

names(datos_test_bakeTraditional)

fit_finalTraditional %>% extract_fit_parsnip() %>% .$fit %>% names()
```

### Algorithms training for Traditional model:
#### Training with GBM:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 810 
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(10000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
opt.Datos.Train.FinnishRecurTraditionaltidymodels <- datos_train_bakeTraditional

levels(opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk) <- c("NoRelapse", "EarlyRelapse", "LateRelpase")

opt.Datos.Train.FinnishRecurTraditionaltidymodels <- droplevels(opt.Datos.Train.FinnishRecurTraditionaltidymodels)

opt.Datos.Test.FinnishRecurTraditionaltidymodels <- datos_test_bakeTraditional

levels(opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk) <- c("NoRelapse", "EarlyRelapse", "LateRelpase")

opt.Datos.Test.FinnishRecurTraditionaltidymodels <- droplevels(opt.Datos.Test.FinnishRecurTraditionaltidymodels)

gbmGrid <-  expand.grid(interaction.depth = c(1, 5, 9), 
                        n.trees = (1:30)*50, 
                        shrinkage = c(0.01,0.05,0.1),
                        n.minobsinnode = c(5,10,20))
```

```{r}
set.seed(123)
TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurTraditionaltidymodels,
                            method="gbm",
                            trControl=fitControl,
                            tuneGrid = gbmGrid,
                            verbose=FALSE,
                            metric='AUC')

TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels

ic_f1Traditional  <- quantile(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$F1, c(.025, .975), na.rm = TRUE)
ic_aucTraditional <- quantile(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$AUC, c(.025, .975), na.rm = TRUE)
ic_senTraditional <- quantile(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Sensitivity, c(.025, .975), na.rm = TRUE)
ic_accTraditional <- quantile(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Accuracy, c(.025, .975), na.rm = TRUE)

#saveRDS(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, file = "TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels.rds")
#TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

#### Rf:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 22
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
rfGrid <-  expand.grid(mtry = (1:22))

set.seed(123)
TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurTraditionaltidymodels,
                            method="rf",
                            tuneGrid = rfGrid,
                            trControl=fitControl,
                            verbose=FALSE,
                            metric='AUC')

TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels

#saveRDS(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, file = "TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")

#TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

#### KNN:

```{r}
knn_grid <- expand.grid(k = seq(3, 21, by = 2)) 
```

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 10
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
set.seed(123)
TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurTraditionaltidymodels,
                            method="knn",
                            trControl=fitControl,
                            metric='AUC',
                            tuneGrid = knn_grid)

TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels

#saveRDS(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, file = "TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")

#TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

#### SVM:

```{r}
svm_grid <- expand.grid(
  C = 2^(-1:2),
  sigma = 2^(-2:1)
)
n_models <- nrow(svm_grid)  # 16 combinations

set.seed(123)
num_folds <- 100 
seeds <- vector(mode = "list", length = num_folds + 1)
for (i in 1:num_folds) {
  seeds[[i]] <- sample.int(1000, n_models)
}

seeds[[num_folds + 1]] <- sample.int(1000, 1)

fitControlSVM <- trainControl(
  method = "repeatedcv",
  number = 10,
  repeats = 10,
  seeds = seeds,
  returnResamp = "final",
  search = "grid",
  verboseIter = FALSE,
  allowParallel = TRUE,
  classProbs = TRUE,
  summaryFunction = metrics_mlmetrics,
  sampling = "smote" 
)
```

```{r}
set.seed(123)
TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurTraditionaltidymodels,
                            method="svmRadial",
                            trControl=fitControlSVM,
                            metric='AUC',
                            tuneGrid = svm_grid)

TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels

#saveRDS(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, file = "TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")

#TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurTraditionaltidymodels),opt.Datos.Train.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
```

### Metrics extraction per class and figures creation:

```{r}
library(caret)
library(yardstick)
library(dplyr)
library(ggplot2)
library(tibble)
library(purrr)

predictionsTidymodelsTraditional <- predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels)

real_classTidymodelsTraditional <- factor(opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)
predictionsTidymodelsTraditional <- factor(predictionsTidymodelsTraditional, levels = levels(real_classTidymodelsTraditional))
probs_tidymodelsTraditional <- predict(
  TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,
  opt.Datos.Test.FinnishRecurTraditionaltidymodels,
  type = "prob"
)

df_resultsTidymodelsTraditional <- tibble(
  truth = real_classTidymodelsTraditional,
  predicted = factor(predictionsTidymodelsTraditional,levels = levels(real_classTidymodelsTraditional))
) %>%
  bind_cols(probs_tidymodelsTraditional)

classesTidymodelsTraditional <- levels(real_classTidymodelsTraditional)

library(rlang)  

calculate_metrics_per_classTidymodelsTraditional <- function(objective_class) {
  df_binaryTraditional <- df_resultsTidymodelsTraditional %>%
    mutate(
      truth_bin = factor(ifelse(truth == objective_class, "Yes", "No"), levels = c("Yes", "No")),
      pred_bin  = factor(ifelse(predicted == objective_class, "Yes", "No"), levels = c("Yes", "No"))
    )
  
   precision <- yardstick::precision(data = df_binaryTraditional, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  recall    <- yardstick::recall(data = df_binaryTraditional, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  f1        <- yardstick::f_meas(data = df_binaryTraditional, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  Accuracy_specific        <- yardstick::accuracy(data = df_binaryTraditional, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  pr_auc_auc  <- pr_auc(df_binaryTraditional, truth_bin, !!sym(objective_class), event_level = "first")$.estimate
  roc_auc_val   <- yardstick::roc_auc(df_binaryTraditional, truth_bin, !!sym(objective_class), event_level = "first")$.estimate

 
   tibble(
    Class = objective_class,
    Metric = c("Precision", "Recall", "F1-score", "Accuracy", "PR AUC", "ROC AUC"),
    Value = c(precision, recall, f1, Accuracy_specific, pr_auc_auc, roc_auc_val)
  )
}

results_per_classTidymodelsTraditional <- map_dfr(classesTidymodelsTraditional, calculate_metrics_per_classTidymodelsTraditional)

print("Metrics per class:")
print(results_per_classTidymodelsTraditional)

Classes_renamed <- list(
  'EarlyRelapse'="Early Relapse",
  'LateRelpase'="Late Relapse",
  'NoRelapse'="No Relapse"
)

Classes_labeller <- function(variable,value){
  return(Classes_renamed[value])
}

PlotMetricsPerClassTidymodelsTraditional <- ggplot(results_per_classTidymodelsTraditional, aes(x = Metric, y = Value, fill = Metric)) +
  geom_text(aes(label = round(Valor, 2)), vjust = -0.5, size = 3) +
  geom_col(show.legend = FALSE) + scale_fill_manual(values=c("blue", "#00BA38", "orange", "purple", "#F8766D", "cyan")) + facet_wrap(~Class, labeller=Classes_labeller) +
  ylim(0, 1) +
  labs(
    title = element_blank(),
    x = element_blank(),
    y = "Value"
  ) +
  theme_minimal(base_size = 10) + theme(axis.text = element_text(colour = "black"), strip.text.x = element_text(colour = "black", face = "bold", size = 12), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))    ####This is Figure 2.A of the manuscript

### RUN TOGETHER:
pdf("PlotMetricsPerClassTidymodelsTraditional.pdf") 
# 2. Create a plot
plot(PlotMetricsPerClassTidymodelsTraditional)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("PlotMetricsPerClassTidymodelsTraditional.png") 
# 2. Create a plot
plot(PlotMetricsPerClassTidymodelsTraditional)
# Close the pdf file
dev.off() 
### UNTIL HERE

PlotMetricsPerClassTidymodelsTraditional

#write.csv(results_per_classTidymodelsTraditional, "MetricsPerClassTraditional.csv") # This is part of Supplementary table S6
```

#### SHAP figures creation 

```{r}
#In this section the different figures shown in Figure 3 of the manuscript are obtained

library(kernelshap)
library(shapviz)

sRFFinnishRecurTraditionaltidymodels <- kernelshap(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, X = opt.Datos.Test.FinnishRecurTraditionaltidymodels[,-23], bg_X = opt.Datos.Test.FinnishRecurTraditionaltidymodels, type = "prob") 

svFinnishRecurTraditionaltidymodels <- shapviz(sRFFinnishRecurTraditionaltidymodels)

FeatureImportanceTraditionaltidymodels <- sv_importance(svFinnishRecurTraditionaltidymodels, kind = "bar",bar_type = "stack" , max_display = 20) + ylab("Feature") + xlab("Average absolute SHAP values") + theme(axis.text.y = element_text(size = 6),axis.text.x = element_text(size = 6),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA))  + scale_y_discrete(labels = c("p53abn","CD171", "Does not smoke", "Hemoglobin", "Age", "ASA Score", "Myometrial invasion","Ca125","Endometrioid G3","Leucocyte","Weakened Ecadherin","BMI","Thrombocyte", "Cytology", "PR","ARID1A","LVSI", "Tumor Size"," Normal Ecadherin",  "Stage I vs II-IV")) + scale_fill_manual(values = c("brown3", "sandybrown", "steelblue1"),labels = c("Late relapse", "Early relapse", "No relapse")) 

FeatureImportanceTraditionaltidymodels

#saveRDS(FeatureImportanceTraditionaltidymodels, "FeatureImportanceTraditionaltidymodels.rds")

#saveRDS(sRFFinnishRecurTraditionaltidymodels, "sRFFinnishRecurTraditionaltidymodels.rds")

#sRFFinnishRecurTraditionaltidymodels <- readRDS("sRFFinnishRecurTraditionaltidymodels.rds")

#FeatureImportanceTraditionaltidymodels <- readRDS("FeatureImportanceTraditionaltidymodels.rds")

### RUN TOGETHER:
pdf("FeatureImportanceTraditionaltidymodels.pdf") 
# 2. Create a plot
plot(FeatureImportanceTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

### RUN TOGETHER:
png("FeatureImportanceTraditionaltidymodels.png") 
# 2. Create a plot
plot(FeatureImportanceTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

FeatureImportanceTraditionaltidymodels
```

```{r}
ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels <- sv_importance(svFinnishRecurTraditionaltidymodels$EarlyRelapse, kind = "beeswarm", max_display = 10) + ylab("Feature") + xlab("SHAP value (impact on model output)") + ggtitle("Feature impact for Early relapse") + theme(axis.text.y = element_text(size = 10), plot.title = element_text(size=12),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA), text=element_text(color="black"),axis.text=element_text(color="black")) + scale_colour_gradient(
    low = "blue", high = "red",
    breaks = c(0, 1), labels = c("Low", "High")) + scale_y_discrete(labels = c("Ca125", "Age","ARID1A","PR", "Normal Ecadherin",  "Myometrial invasion",
  "Endometrioid G3","Thrombocyte", "Positive cytology", "Stage I vs II-IV"))

ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels

### RUN TOGETHER:
pdf("ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels.pdf") 
# 2. Create a plot
plot(ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels.png") 
# 2. Create a plot
plot(ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

ShapelyGraphicFinnishEarlyRecurTraditionaltidymodels
```

```{r}
ShapelyGraphicFinnishLateRecurTraditionaltidymodels <- sv_importance(svFinnishRecurTraditionaltidymodels$LateRelpase , kind = "beeswarm", max_display = 10) + ylab("Feature") + xlab("SHAP value (impact on model output)") + ggtitle("Feature impact for Late relapse") + theme(axis.text.y = element_text(size = 10), plot.title = element_text(size=12),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA), text=element_text(color="black"),axis.text=element_text(color="black")) + scale_colour_gradient(
    low = "blue", high = "red",
    breaks = c(0, 1), labels = c("Low", "High"))+ scale_y_discrete(labels = c("Stage I vs II-IV","Hemoglobin","Leucocyte","ASA Score", "BMI","Endometrioid G3","ARID1A","LVSI", "Tumor size","Normal Ecadherin")) 

ShapelyGraphicFinnishLateRecurTraditionaltidymodels

### RUN TOGETHER:
pdf("ShapelyGraphicFinnishLateRecurTraditionaltidymodels.pdf") 
# 2. Create a plot
plot(ShapelyGraphicFinnishLateRecurTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ShapelyGraphicFinnishLateRecurTraditionaltidymodels.png") 
# 2. Create a plot
plot(ShapelyGraphicFinnishLateRecurTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

ShapelyGraphicFinnishLateRecurTraditionaltidymodels
```

```{r}
ShapelyGraphicFinnishNoRecurTraditionaltidymodels <- sv_importance(svFinnishRecurTraditionaltidymodels$NoRelapse, kind = "beeswarm", max_display = 10) + ylab("Feature") + xlab("SHAP value (impact on model output)") + ggtitle("Feature impact for no relapse") + theme(axis.text.y = element_text(size = 10), plot.title = element_text(size=12),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA), text=element_text(color="black"),axis.text=element_text(color="black")) + scale_colour_gradient(
    low = "blue", high = "red",
    breaks = c(0, 1), labels = c("Low", "High")) + scale_y_discrete(labels = c("Ca125", "Positive cytology", "Leucocyte", "Weakened Ecadherin", "PR", "ARID1A", "LVSI", "Tumor size", "Normal Ecadherin", "Stage I vs II-IV"))


ShapelyGraphicFinnishNoRecurTraditionaltidymodels

### RUN TOGETHER:
pdf("ShapelyGraphicFinnishNoRecurTraditionaltidymodels.pdf") 
# 2. Create a plot
plot(ShapelyGraphicFinnishNoRecurTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ShapelyGraphicFinnishNoRecurTraditionaltidymodels.png") 
# 2. Create a plot
plot(ShapelyGraphicFinnishNoRecurTraditionaltidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

ShapelyGraphicFinnishNoRecurTraditionaltidymodels  ####Tumour size > 25 mm
```

```{r}
library(gbm)
ImportanceFinnishRecurTraditionalTidymodels <- varImp(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, scale = FALSE)

ImportanceFinnishRecurTraditionalTidymodels <- ImportanceFinnishRecurTraditionalTidymodels$importance

ImportanceFinnishRecurTraditionalTidymodels <- cbind(ImportanceFinnishRecurTraditionalTidymodels, row.names(ImportanceFinnishRecurTraditionalTidymodels))
```

```
ImportanceFinnishRecurTraditionalTidymodelsSorted <- ImportanceFinnishRecurTraditionalTidymodels[order(ImportanceFinnishRecurTraditionalTidymodels$Overall, decreasing = TRUE),]
```

#### Confusion matrix creation:

```{r}
#This code generates the confusion matrix shown in Figure 2B of the manuscript

cm <- confusionMatrix(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

cm_table <- as.data.frame(cm$table)

ConfusionMatrixFigureRelapseRisk <- ggplot(cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Freq), color = "coral", size = 4) +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  labs(x = element_blank(),y = "Predicted class",
    fill = "Frequency"
  ) +
  theme_minimal() +
  theme(axis.text = element_text(size = 10,color="black"),
    axis.title = element_text(size = 12),
    legend.position = "right", text=element_text(color="black")
  ) + scale_x_discrete(labels= c("No relapse", "Early relapse", "Late relapse")) +
   scale_y_discrete(labels=c("No relapse", "Early relapse", "Late relapse"))

ConfusionMatrixFigureRelapseRisk

### RUN TOGETHER:
pdf("ConfusionMatrixFigureRelapseRisk.pdf") 
# 2. Create a plot
plot(ConfusionMatrixFigureRelapseRisk)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ConfusionMatrixFigureRelapseRisk.png") 
# 2. Create a plot
plot(ConfusionMatrixFigureRelapseRisk)
# Close the pdf file
dev.off() 
### UNTIL HERE

ConfusionMatrixFigureRelapseRisk
```


### ESGO rfe with tidymodels:

```{r}
# install.packages(c("tidymodels", "vip", "themis"))

library(tidymodels)
library(vip)
library(themis)

DatasetRiskOfRecurrenceESGO <- read_csv("DatasetESGORiskOfRecurrence.csv")

DatasetRiskOfRecurrenceESGO <- DatasetRiskOfRecurrenceESGO %>%
  dplyr::select(!Time)

DatasetRiskOfRecurrenceESGO <- DatasetRiskOfRecurrenceESGO%>%
  mutate(across(where(is.character), as.factor))

FirstrecipeESGO <- recipe(`RecurrenceRisk` ~ ., data =DatasetRiskOfRecurrenceESGO) %>%  
  step_dummy(all_nominal_predictors())          
    
set.seed(123)
splitESGO <- initial_split(DatasetRiskOfRecurrenceESGO, prop = 0.7, strata = `RecurrenceRisk`)
datos_trainESGO <- training(splitESGO)
datos_testValidationESGO  <- testing(splitESGO)

splitESGO2 <- initial_split(datos_testValidationESGO, prop = 0.7, strata = `RecurrenceRisk`)
datos_testESGO <- training(splitESGO2)
datos_ValidationESGO  <- testing(splitESGO2)

datos_trainESGO <- datos_trainESGO %>%
  mutate(across(where(is.character), as.factor))

datos_testESGO <- datos_testESGO %>%
  mutate(across(where(is.character), as.factor))

datos_ValidationESGO <- datos_ValidationESGO %>%
  mutate(across(where(is.character), as.factor))

datos_trainESGO <- datos_trainESGO %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_testESGO <- datos_testESGO %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_ValidationESGO <- datos_ValidationESGO %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_trainESGO$recurrence_risk <- factor(datos_trainESGO$recurrence_risk)

datos_testESGO$recurrence_risk <- factor(datos_testESGO$recurrence_risk, levels = levels(datos_trainESGO$recurrence_risk))

datos_ValidationESGO$recurrence_risk <- factor(datos_ValidationESGO$recurrence_risk, levels = levels(datos_trainESGO$recurrence_risk))

datos_trainESGO <- na.roughfix(datos_trainESGO)

datos_testESGO <- na.roughfix(datos_testESGO)

datos_ValidationESGO <- na.roughfix(datos_ValidationESGO)

Base_recipeESGO <- recipe(recurrence_risk ~ ., data = datos_trainESGO) %>%
  step_zv(all_predictors()) %>%                      
  step_normalize(all_numeric_predictors()) %>%    
  step_dummy(all_nominal_predictors())           

Base_recipe_preparedESGO <- prep(Base_recipeESGO, training = datos_trainESGO, retain = TRUE)

data_processedESGO <- juice(Base_recipe_preparedESGO)

model_rfESGO <- rand_forest(mode = "classification", trees = 500) %>%
  set_engine("ranger", importance = "impurity")

model_baseESGO <- model_rfESGO %>%
  fit(recurrence_risk ~ ., data = datos_procesadosESGO)

vip_valsESGO <- model_baseESGO %>% vi()

sorted_variablesESGO <- vip_valsESGO %>%
  arrange(desc(Importance)) %>%
  pull(Variable)

cv_foldsESGO <- vfold_cv(datos_trainESGO, v = 5, strata = recurrence_risk)

evalute_with_top_nESGO <- function(n) {
  print(n)
  n_local <- n
  top_varsESGO <- sorted_variablesESGO[1:n_local]
  top_varsESGO <- union(top_varsESGO, "recurrence_risk")
  
  recipe_rfeESGO <- recipe(recurrence_risk ~ ., data = datos_trainESGO) %>%
    step_zv(all_predictors()) %>%
    step_normalize(all_numeric_predictors()) %>%
    step_dummy(all_nominal_predictors()) %>%
    step_smote(recurrence_risk) %>%
    step_select(all_of(top_varsESGO))
  
  wfESGO <- workflow() %>%
    add_model(model_rfESGO) %>%
    add_recipe(recipe_rfeESGO) 

  resESGO <- fit_resamples(
    wfESGO,
    resamples = cv_foldsESGO,
    metrics = metric_set(accuracy, f_meas, kap, roc_auc, pr_auc),
    control = control_resamples(save_pred = TRUE)
  )
  
  collect_metrics(resESGO) %>%
    mutate(num_vars = n_local)
}

top_n_values <- c(5:30)

results_rfeESGO <- map_dfr(top_n_values, evalute_with_top_nESGO)

#saveRDS(results_rfeESGO, "RFEresultsTP53ESGO.rds")
#saveRDS(sorted_variablesESGO, "MoreToleastImportantFeaturesESGO.rds")
#write.csv(results_rfeESGO, "RFEresultsESGO.csv")

best_nESGO <- results_rfeESGO %>%
  filter(.metric == "f_meas") %>%
  arrange(desc(mean)) %>%
  slice(1) %>%
  pull(num_vars)

cat("Best number of features according to F1-score:", best_nESGO, "\n")

best_varsESGO <- sorted_variablesESGO[1:23]

best_varsESGO <- setdiff(best_varsESGO, "recurrence_risk")

recipe_finalESGO <- recipe(recurrence_risk ~ ., data = datos_trainESGO) %>%
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>%
  update_role(recurrence_risk, new_role = "outcome") %>%
  step_select(all_of(best_varsESGO), starts_with("recurrence_risk")) %>%
  step_smote(recurrence_risk, skip = TRUE)

prep(recipe_finalESGO, training = datos_trainESGO) %>% juice() %>% names() %>% any(. == "recurrence_risk")

wf_finalESGO <- workflow() %>%
  add_model(model_rfESGO) %>%
  add_recipe(recipe_finalESGO)

fit_finalESGO <- fit(
  wf_finalESGO,
  data = datos_trainESGO)

recipe_evalESGO <- recipe_finalESGO %>% prep(training = datos_trainESGO, retain = TRUE)
datos_train_bakeESGO <- bake(recipe_evalESGO, new_data = datos_trainESGO)
datos_test_bakeESGO <- bake(recipe_evalESGO, new_data = datos_testESGO)

names(datos_test_bakeESGO)

fit_finalESGO %>% extract_fit_parsnip() %>% .$fit %>% names()
```

### Algorithms training for ESGO-based model:
#### Training with GBM:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 810 
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(10000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
opt.Datos.Train.FinnishRecurESGOtidymodels <- datos_train_bakeESGO

levels(opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk) <- c("EarlyRelapse", "LateRelpase", "NoRelapse")

opt.Datos.Train.FinnishRecurESGOtidymodels <- droplevels(opt.Datos.Train.FinnishRecurESGOtidymodels)

opt.Datos.Test.FinnishRecurESGOtidymodels <- datos_test_bakeESGO

levels(opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk) <- c("EarlyRelapse", "LateRelpase", "NoRelapse")

opt.Datos.Test.FinnishRecurESGOtidymodels <- droplevels(opt.Datos.Test.FinnishRecurESGOtidymodels)

gbmGrid <-  expand.grid(interaction.depth = c(1, 5, 9), 
                        n.trees = (1:30)*50, 
                        shrinkage = c(0.01,0.05,0.1),
                        n.minobsinnode = c(5,10,20))
```

```{r}
set.seed(123)
ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurESGOtidymodels,
                            method="gbm",
                            trControl=fitControl,
                            tuneGrid = gbmGrid,
                            metric='AUC')

ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels

ic_f1ESGO  <- quantile(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$F1, c(.025, .975), na.rm = TRUE)
ic_aucESGO <- quantile(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$AUC, c(.025, .975), na.rm = TRUE)
ic_senESGO <- quantile(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Sensitivity, c(.025, .975), na.rm = TRUE)
ic_accESGO <- quantile(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Accuracy, c(.025, .975), na.rm = TRUE)

#saveRDS(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, file = "ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels.rds")

ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

#### Rf:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 23 
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
rfGrid <-  expand.grid(mtry = (1:23))

set.seed(123)
ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurESGOtidymodels,
                            method="rf",
                            tuneGrid = rfGrid,
                            trControl=fitControl,
                            metric='AUC')

ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels


#saveRDS(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, file = "ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")

#ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- readRDS(file = "ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```


#### KNN:

```{r}
knn_grid <- expand.grid(k = seq(3, 21, by = 2)) 
```

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 10
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
set.seed(123)
ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurESGOtidymodels,
                            method="knn",
                            trControl=fitControl,
                            metric='AUC',
                            tuneGrid = knn_grid)

ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels

#saveRDS(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, file = "ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")

#ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- readRDS(file = "ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

#### SVM:

```{r}
svm_grid <- expand.grid(
  C = 2^(-1:2),
  sigma = 2^(-2:1)
)
n_models <- nrow(svm_grid)  # 16 combinations

set.seed(123)
num_folds <- 100 
seeds <- vector(mode = "list", length = num_folds + 1)
for (i in 1:num_folds) {
  seeds[[i]] <- sample.int(1000, n_models)
}

seeds[[num_folds + 1]] <- sample.int(1000, 1)

fitControlSVM <- trainControl(
  method = "repeatedcv",
  number = 10,
  repeats = 10,
  seeds = seeds,
  returnResamp = "final",
  search = "grid",
  verboseIter = FALSE,
  allowParallel = TRUE,
  classProbs = TRUE,
  summaryFunction = metrics_mlmetrics,
  sampling = "smote" 
)
```

```{r}
set.seed(123)
ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurESGOtidymodels,
                            method="svmRadial",
                            trControl=fitControlSVM  ,
                            metric='AUC',
                            tuneGrid = svm_grid)

ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels

#saveRDS(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, file = "ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")

#ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurESGOtidymodels),opt.Datos.Train.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
```

### Metrics extraction per class and figures creation:

```{r}
library(caret)
library(yardstick)
library(dplyr)
library(ggplot2)
library(tibble)
library(purrr)

predictionsTidymodelsESGO <- predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels)

real_classTidymodelsESGO <- factor(opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)
predictionsTidymodelsESGO <- factor(predictionsTidymodelsESGO, levels = levels(clase_realTidymodelsESGO))
probs_tidymodelsESGO <- predict(
  ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,
  opt.Datos.Test.FinnishRecurESGOtidymodels,
  type = "prob"
)

df_resultsTidymodelsESGO <- tibble(
  truth = real_classTidymodelsESGO,
  predicted = factor(predictionsTidymodelsESGO,levels = levels(real_classTidymodelsESGO))
) %>%
  bind_cols(probs_tidymodelsESGO)

classesTidymodelsESGO <- levels(real_classTidymodelsESGO)

library(rlang)  

calculate_metrics_per_classTidymodelsESGO <- function(objective_class) {
  df_binaryESGO <- df_resultsTidymodelsESGO %>%
    mutate(
      truth_bin = factor(ifelse(truth == objective_class, "Yes", "No"), levels = c("Yes", "No")),
      pred_bin  = factor(ifelse(predicted == objective_class, "Yes", "No"), levels = c("Yes", "No"))
      )
  
   precision <- yardstick::precision(data = df_binaryESGO, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  recall    <- yardstick::recall(data = df_binaryESGO, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  f1        <- yardstick::f_meas(data = df_binaryESGO, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  Accuracy_specific        <- yardstick::accuracy(data = df_binaryESGO, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  pr_auc_auc  <- pr_auc(df_binaryESGO, truth_bin, !!sym(objective_class), event_level = "first")$.estimate
  roc_auc_val   <- yardstick::roc_auc(df_binaryESGO, truth_bin, !!sym(objective_class), event_level = "first")$.estimate

   tibble(
    Class = objective_class,
    Metric = c("Precision", "Recall", "F1-score", "Accuracy", "PR AUC", "ROC AUC"),
    Value = c(precision, recall, f1, Accuracy_specific, pr_auc_auc, roc_auc_val)
  )
}

results_per_classTidymodelsESGO <- map_dfr(classesTidymodelsESGO, calculate_metrics_per_classTidymodelsESGO)

print("Metrics per class:")
print(results_per_classTidymodelsESGO)

Spaced_classes <- list(
  'EarlyRelapse'="Early Relapse",
  'LateRelpase'="Late Relapse",
  'NoRelapse'="No Relapse"
)

Classes_labeller <- function(variable,value){
  return(Spaced_classes[value])
}

PlotMetricsPerClassTidymodelsESGO <- ggplot(results_per_classTidymodelsESGO, aes(x = Metric, y = Value, fill = Metric)) + 
  geom_text(aes(label = round(Valor, 2)), vjust = -0.5, size = 3) +
  geom_col(show.legend = FALSE) + scale_fill_manual(values=c("blue", "#00BA38", "orange", "purple", "#F8766D", "cyan")) + facet_wrap(~Class, labeller=Classes_labeller) +
  ylim(0, 1) +
  labs(
    title = "Metrics per class",
    x = "Metric",
    y = "Value"
  ) +
  theme_minimal(base_size = 8)

PlotMetricsPerClassTidymodelsESGO

### RUN TOGETHER:
pdf("PlotMetricsPerClassTidymodelsESGO.pdf") 
# 2. Create a plot
plot(PlotMetricsPerClassTidymodelsESGO)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("PlotMetricsPerClassTidymodelsESGO.png") 
# 2. Create a plot
plot(PlotMetricsPerClassTidymodelsESGO)
# Close the pdf file
dev.off() 
### UNTIL HERE

PlotMetricsPerClassTidymodelsESGO
```

```{r}
library(gbm)
ImportanceFinnishRecurESGOTidymodels <- varImp(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, scale = FALSE)

ImportanceFinnishRecurESGOTidymodels <- ImportanceFinnishRecurESGOTidymodels$importance

ImportanceFinnishRecurESGOTidymodels <- cbind(ImportanceFinnishRecurESGOTidymodels, row.names(ImportanceFinnishRecurESGOTidymodels))
```

```{r}
ImportanceFinnishRecurESGOTidymodelsSorted <- ImportanceFinnishRecurESGOTidymodels[order(ImportanceFinnishRecurESGOTidymodels$Overall, decreasing = TRUE),]
```

### POLE rfe with tidymodels:

```{r}
DatasetRiskOfRecurrencePOLE <- read_csv("DatasetPOLERiskOfRecurrence.csv")

DatasetRiskOfRecurrencePOLE <- DatasetRiskOfRecurrencePOLE %>%
  dplyr::select(!Time)

DatasetRiskOfRecurrencePOLE <- DatasetRiskOfRecurrencePOLE %>%
  mutate(across(where(is.character), as.factor))
```

```{r}
# install.packages(c("tidymodels", "vip", "themis"))

library(tidymodels)
library(vip)
library(themis)

recipePOLE <- recipe(`RecurrenceRisk` ~ ., data =DatasetRiskOfRecurrencePOLE) %>%
    step_dummy(all_nominal_predictors())            # Transforms factor features to dummies
    
set.seed(123)
splitPOLE <- initial_split(DatasetRiskOfRecurrencePOLE, prop = 0.7, strata = `RecurrenceRisk`)
datos_trainPOLE <- training(splitPOLE)
datos_testValidationPOLE  <- testing(splitPOLE)

splitPOLE2 <- initial_split(datos_testValidationPOLE, prop = 0.7, strata = `RecurrenceRisk`)
datos_testPOLE <- training(splitPOLE2)
datos_ValidationPOLE  <- testing(splitPOLE2)

datos_trainPOLE <- datos_trainPOLE %>%
  mutate(across(where(is.character), as.factor))

datos_testPOLE <- datos_testPOLE %>%
  mutate(across(where(is.character), as.factor))

datos_ValidationPOLE <- datos_ValidationPOLE %>%
  mutate(across(where(is.character), as.factor))

datos_trainPOLE <- datos_trainPOLE %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_testPOLE <- datos_testPOLE %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_ValidationPOLE <- datos_ValidationPOLE %>%
  rename(recurrence_risk = `RecurrenceRisk`)

datos_trainPOLE$recurrence_risk <- factor(datos_trainPOLE$recurrence_risk)

datos_testPOLE$recurrence_risk <- factor(datos_testPOLE$recurrence_risk, levels = levels(datos_trainPOLE$recurrence_risk))

datos_ValidationPOLE$recurrence_risk <- factor(datos_ValidationPOLE$recurrence_risk, levels = levels(datos_trainPOLE$recurrence_risk))

datos_trainPOLE <- na.roughfix(datos_trainPOLE)

datos_testPOLE <- na.roughfix(datos_testPOLE)

datos_ValidationPOLE <- na.roughfix(datos_ValidationPOLE)

Base_recipePOLE <- recipe(recurrence_risk ~ ., data = datos_trainPOLE) %>%
  step_zv(all_predictors()) %>%                     
  step_normalize(all_numeric_predictors()) %>%    
  step_dummy(all_nominal_predictors())            

Base_recipe_preparedPOLE <- prep(Base_recipePOLE, training = datos_trainPOLE, retain = TRUE)

Processed_dataPOLE <- juice(Base_recipe_preparedPOLE)

model_rfPOLE <- rand_forest(mode = "classification", trees = 500) %>%
  set_engine("ranger", importance = "impurity")

model_basePOLE <- model_rfPOLE %>%
  fit(recurrence_risk ~ ., data = Processed_dataPOLE)

vip_valsPOLE <- model_basePOLE %>% vi()

sorted_variablesPOLE <- vip_valsPOLE %>%
  arrange(desc(Importance)) %>%
  pull(Variable)

cv_foldsPOLE <- vfold_cv(datos_trainPOLE, v = 5, strata = recurrence_risk)

set.seed(123)
evaluate_with_top_nPOLE <- function(n) {
  print(n)
  n_local <- n
  top_varsPOLE <- sorted_variablesPOLE[1:n_local]
  top_varsPOLE <- union(top_varsPOLE, "recurrence_risk")
  
  recipe_rfePOLE <- recipe(recurrence_risk ~ ., data = datos_trainPOLE) %>%
    step_zv(all_predictors()) %>%
    step_normalize(all_numeric_predictors()) %>%
    step_dummy(all_nominal_predictors()) %>%
    step_smote(recurrence_risk) %>%
    step_select(all_of(top_varsPOLE))
  
  wfPOLE <- workflow() %>%
    add_model(model_rfPOLE) %>%
    add_recipe(recipe_rfePOLE) 

  resPOLE <- fit_resamples(
    wfPOLE,
    resamples = cv_foldsPOLE,
    metrics = metric_set(accuracy, f_meas, kap, roc_auc, pr_auc),
    control = control_resamples(save_pred = TRUE)
  )
  
  collect_metrics(resPOLE) %>%
    mutate(num_vars = n_local)
}

top_n_values <- c(5:30)

results_rfePOLE <- map_dfr(top_n_values, evaluate_with_top_nPOLE)

#saveRDS(results_rfePOLE, "RFEresultsTP53POLE.rds")
#saveRDS(sorted_variablesPOLE, "MoreToleastImportantFeaturesPOLE.rds")
#write.csv(results_rfePOLE, "RFEresultsPOLE.csv")

Best_nPOLE <- results_rfePOLE %>%
  filter(.metric == "f_meas") %>%
  arrange(desc(mean)) %>%
  slice(1) %>%
  pull(num_vars)

cat("Best number of features according to F1-score:", results_rfePOLE, "\n")

Best_varsPOLE <- sorted_variablesPOLE[1:28]

Best_varsPOLE <- setdiff(Best_varsPOLE, "recurrence_risk")

recipe_finalPOLE <- recipe(recurrence_risk ~ ., data = datos_trainPOLE) %>%
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>%
  update_role(recurrence_risk, new_role = "outcome") %>%
  step_select(all_of(Best_varsPOLE), starts_with("recurrence_risk")) %>%
  step_smote(recurrence_risk, skip = TRUE)

prep(recipe_finalPOLE, training = datos_trainPOLE) %>% juice() %>% names() %>% any(. == "recurrence_risk")

wf_finalPOLE <- workflow() %>%
  add_model(model_rfPOLE) %>%
  add_recipe(recipe_finalPOLE)

fit_finalPOLE <- fit(
  wf_finalPOLE,
  data = datos_trainPOLE)

recipe_evalPOLE <- recipe_finalPOLE %>% prep(training = datos_trainPOLE, retain = TRUE)
datos_train_bakePOLE <- bake(recipe_evalPOLE, new_data = datos_trainPOLE)
datos_test_bakePOLE <- bake(recipe_evalPOLE, new_data = datos_testPOLE)

names(datos_test_bakePOLE)

fit_finalPOLE %>% extract_fit_parsnip() %>% .$fit %>% names()
```

### Algorithms training for POLE model:
#### Training with GBM:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 810
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(10000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
opt.Datos.Train.FinnishRecurPOLEtidymodels <- datos_train_bakePOLE

levels(opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk) <- c("NoRelapse","EarlyRelapse", "LateRelpase")

opt.Datos.Train.FinnishRecurPOLEtidymodels <- droplevels(opt.Datos.Train.FinnishRecurPOLEtidymodels)

opt.Datos.Test.FinnishRecurPOLEtidymodels <- datos_test_bakePOLE

levels(opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk) <- c("NoRelapse","EarlyRelapse", "LateRelpase")

opt.Datos.Test.FinnishRecurPOLEtidymodels <- droplevels(opt.Datos.Test.FinnishRecurPOLEtidymodels)

gbmGrid <-  expand.grid(interaction.depth = c(1, 5, 9), 
                        n.trees = (1:30)*50, 
                        shrinkage = c(0.01,0.05,0.1),
                        n.minobsinnode = c(5,10,20))
```

```{r}
set.seed(123)
POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurPOLEtidymodels,
                            method="gbm",
                            trControl=fitControl,
                            tuneGrid = gbmGrid,
                            metric='AUC')

POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels

ic_f1POLE  <- quantile(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$F1, c(.025, .975), na.rm = TRUE)
ic_aucPOLE <- quantile(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$AUC, c(.025, .975), na.rm = TRUE)
ic_senPOLE <- quantile(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Sensitivity, c(.025, .975), na.rm = TRUE)
ic_accPOLE <- quantile(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels$resample$Accuracy, c(.025, .975), na.rm = TRUE)

#saveRDS(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, file = "POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels.rds")

#POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

#### Rf:

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 28
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
rfGrid <-  expand.grid(mtry = (1:28))

set.seed(123)
POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurPOLEtidymodels,
                            method="rf",
                            tuneGrid = rfGrid,
                            trControl=fitControl,
                            metric='AUC')

POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels

#saveRDS(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, file = "POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")

#POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- readRDS(file = "POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```



#### KNN:

```{r}
knn_grid <- expand.grid(k = seq(3, 21, by = 2)) 
```

```{r}
library(pROC) 

metrics_mlmetrics <- function(data, lev = NULL, model = NULL) {
  
  y_true <- data$obs
  y_pred <- data$pred
  y_prob <- data[[lev[1]]] 
  
  f1  <- F1_Score(y_true = y_true, y_pred = y_pred, positive = lev[1])
  acc <- Accuracy(y_true = y_true, y_pred = y_pred)
  sens <- Sensitivity(y_true = y_true, y_pred = y_pred, positive = lev[1])
  auc <- auc(y_true, y_prob)
  
  c(F1 = f1, AUC = as.numeric(auc), Sensitivity = sens, Accuracy = acc)
}

set.seed(123)
n_values = 10
seeds <- vector(mode = "list", length = 101)
for(i in 1:100) seeds[[i]] <- sample.int(1000, n_values)
seeds[[101]] <- sample.int(1000, 1)

fitControl <- trainControl(## 10-fold repeated CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 10,    ## repeated ten times
                           seeds = seeds,
                           returnResamp = "final",
                           search = "grid",
                           verboseIter=FALSE,
                           allowParallel = TRUE,
                           classProbs = T,
                           summaryFunction = metrics_mlmetrics)

fitControl$sampling <- "smote"
```

```{r}
set.seed(123)
POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurPOLEtidymodels,
                            method="knn",
                            trControl=fitControl,
                            metric='AUC',
                            tuneGrid = knn_grid)

POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels

#saveRDS(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, file = "POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")

POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels <- readRDS(file = "POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

#### SVM:

```{r}
svm_grid <- expand.grid(
  C = 2^(-1:2),
  sigma = 2^(-2:1)
)
n_models <- nrow(svm_grid)  # 16 combinations

set.seed(123)
num_folds <- 100 
seeds <- vector(mode = "list", length = num_folds + 1)
for (i in 1:num_folds) {
  seeds[[i]] <- sample.int(1000, n_models)
}

seeds[[num_folds + 1]] <- sample.int(1000, 1)

fitControlSVM <- trainControl(
  method = "repeatedcv",
  number = 10,
  repeats = 10,
  seeds = seeds,
  returnResamp = "final",
  search = "grid",
  verboseIter = FALSE,
  allowParallel = TRUE,
  classProbs = TRUE,
  summaryFunction = metrics_mlmetrics,
  sampling = "smote" 
)
```
```{r}
set.seed(123)
POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- train(recurrence_risk ~ ., data = opt.Datos.Train.FinnishRecurPOLEtidymodels,
                            method="svmRadial",
                            trControl=fitControlSVM  ,
                            metric='AUC',
                            tuneGrid = svm_grid)

POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels

#saveRDS(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, file = "POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")

#POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels <- readRDS(file = "POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels.rds")
```

```{r}
library(MLmetrics)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Train.FinnishRecurPOLEtidymodels),opt.Datos.Train.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Accuracy(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

```{r}
confusionMatrix(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
```

### Metrics extraction per class and figures creation:

```{r}
library(caret)
library(yardstick)
library(dplyr)
library(ggplot2)
library(tibble)
library(purrr)

predictionsTidymodelsRiskPOLE <- predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels)

real_classTidymodelsPOLE <- factor(opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)
predictionsTidymodelsRiskPOLE <- factor(predictionsTidymodelsRiskPOLE, levels = levels(clase_realTidymodelsPOLE))
probs_tidymodelsPOLE <- predict(
  POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,
  opt.Datos.Test.FinnishRecurPOLEtidymodels,
  type = "prob"
)

df_resultsTidymodelsPOLE <- tibble(
  truth = clase_realTidymodelsPOLE,
  predicted = factor(predictionsTidymodelsRiskPOLE,levels = levels(real_classTidymodelsPOLE))
) %>%
  bind_cols(probs_tidymodelsPOLE)

classesTidymodelsPOLE <- levels(real_classTidymodelsPOLE)

library(rlang)  

calculate_metrics_per_classTidymodelsPOLE <- function(objective_class) {
  df_binaryPOLE <- df_resultsTidymodelsPOLE %>%
    mutate(
      truth_bin = factor(ifelse(truth == objective_class, "Yes", "No"), levels = c("Yes", "No")),
      pred_bin  = factor(ifelse(predicted == objective_class, "Yes", "No"), levels = c("Yes", "No"))
    )
  
   precision <- yardstick::precision(data = df_binaryPOLE, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  recall    <- yardstick::recall(data = df_binaryPOLE, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  f1        <- yardstick::f_meas(data = df_binaryPOLE, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  Accuracy_specific        <- yardstick::accuracy(data = df_binaryPOLE, truth = truth_bin, estimate = pred_bin, event_level = "first")$.estimate
  pr_auc_auc  <- pr_auc(df_binaryPOLE, truth_bin, !!sym(objective_class), event_level = "first")$.estimate
  roc_auc_val   <- yardstick::roc_auc(df_binaryPOLE, truth_bin, !!sym(objective_class), event_level = "first")$.estimate
    
   tibble(
    Class = objective_class,
    Metric = c("Precision", "Recall", "F1-score", "Accuracy", "PR AUC", "ROC AUC"),
    Value = c(precision, recall, f1, Accuracy_specific, pr_auc_auc, roc_auc_val)
  )
}

results_per_classTidymodelsPOLE <- map_dfr(classesTidymodelsPOLE, calculate_metrics_per_classTidymodelsPOLE)

print("Metrics per class:")
print(results_per_classTidymodelsPOLE)

Spaced_classes <- list(
  'EarlyRelapse'="Early Relapse",
  'LateRelpase'="Late Relapse",
  'NoRelapse'="No Relapse"
)

Classes_labeller <- function(variable,value){
  return(Spaced_classes[value])
}

PlotMetricsPerClassTidymodelsPOLE <- ggplot(results_per_classTidymodelsPOLE, aes(x = Metric, y = Value, fill = Metric)) +
  geom_text(aes(label = round(Valor, 2)), vjust = -0.5, size = 3) +
  geom_col(show.legend = FALSE) + scale_fill_manual(values=c("blue", "#00BA38", "orange", "purple", "#F8766D","cyan")) + facet_wrap(~Class, labeller=Classes_labeller) +
  ylim(0, 1) +
  labs(
    title = element_blank(),
    x = element_blank(),
    y = "Value"
  ) +
  theme_minimal(base_size = 10) + theme(axis.text = element_text(colour = "black"), strip.text.x = element_text(colour = "black", face = "bold", size = 12), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 

### RUN TOGETHER:
pdf("PlotMetricsPerClassTidymodelsPOLE.pdf") 
# 2. Create a plot
plot(PlotMetricsPerClassTidymodelsPOLE)
# Close the pdf file
dev.off() 
### UNTIL HERE

### RUN TOGETHER:
png("PlotMetricsPerClassTidymodelsPOLE.png") 
# 2. Create a plot
plot(PlotMetricsPerClassTidymodelsPOLE)
# Close the pdf file
dev.off() 
### UNTIL HERE

PlotMetricsPerClassTidymodelsPOLE   #This is Figure 4A of the manuscript

#write.csv(results_per_classTidymodelsPOLE, "MetricsPerClassPOLE.csv")  #This is the other part of Supplementary table 6
```

```{r}
library(gbm)
ImportanceFinnishRecurPOLETidymodels <- varImp(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, scale = FALSE)

ImportanceFinnishRecurPOLETidymodels <- ImportanceFinnishRecurPOLETidymodels$importance

ImportanceFinnishRecurPOLETidymodels <- cbind(ImportanceFinnishRecurPOLETidymodels, row.names(ImportanceFinnishRecurPOLETidymodels))
```

```{r}
ImportanceFinnishRecurPOLETidymodelsSorted <- ImportanceFinnishRecurPOLETidymodels[order(ImportanceFinnishRecurPOLETidymodels$Overall, decreasing = TRUE),]
```

#### SHAP figures creation

```{r}
#In this section the different figures shown in Figure 5 of the manuscript are obtained

library(kernelshap)
library(shapviz)

sRFFinnishRecurPOLEtidymodels <- kernelshap(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, X = opt.Datos.Test.FinnishRecurPOLEtidymodels[,-29], bg_X = opt.Datos.Test.FinnishRecurPOLEtidymodels, type = "prob") 

svFinnishRecurPOLEtidymodels <- shapviz(sRFFinnishRecurPOLEtidymodels)

FeatureImportancePOLEtidymodels <- sv_importance(svFinnishRecurPOLEtidymodels, kind = "bar",bar_type = "stack" , max_display = 20) + ylab("Feature") + xlab("Average absolute SHAP values") + theme(axis.text.y = element_text(size = 6),axis.text.x = element_text(size = 6),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA))  + scale_y_discrete(labels = c("PDL1", "Does not smoke", "BMI", "Non endometrioid", "ASA Score", "Hemoglobin", "Diabetic" ,"Ca125", "Age",  "ARID1A", "Weakened Ecadherin", "Myometrial invasion", "LVSI", "Leucocyte", "Thrombocyte", "PR", "Positive cytology", "Normal Ecadherin", "Tumor Size", "Stage I vs II-IV")) + scale_fill_manual(values = c("brown3", "sandybrown", "steelblue1"),labels = c("Late relapse", "Early relapse", "No relapse")) 

FeatureImportancePOLEtidymodels

#saveRDS(FeatureImportancePOLEtidymodels, "FeatureImportancePOLEtidymodels.rds")

#saveRDS(sRFFinnishRecurPOLEtidymodels, "sRFFinnishRecurPOLEtidymodels.rds")

sRFFinnishRecurPOLEtidymodels <- readRDS("sRFFinnishRecurPOLEtidymodels.rds")

FeatureImportancePOLEtidymodels <- readRDS("FeatureImportancePOLEtidymodels.rds")

### RUN TOGETHER:
pdf("FeatureImportancePOLEtidymodels.pdf") 
# 2. Create a plot
plot(FeatureImportancePOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("FeatureImportancePOLEtidymodels.png") 
# 2. Create a plot
plot(FeatureImportancePOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

FeatureImportancePOLEtidymodels
```

```{r}
ShapelyGraphicFinnishEarlyRecurPOLEtidymodels <- sv_importance(svFinnishRecurPOLEtidymodels$EarlyRelapse, kind = "beeswarm", max_display = 10) + ylab("Feature") + xlab("SHAP value (impact on model output)") + ggtitle("Feature impact for Early relapse") + theme(axis.text.y = element_text(size = 10), plot.title = element_text(size=12),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA), text=element_text(color="black"),axis.text=element_text(color="black")) + scale_colour_gradient(
    low = "blue", high = "red",
    breaks = c(0, 1), labels = c("Low", "High")) + scale_y_discrete(labels = c( "PR", "Tumor size","Leucocyte", "Non endometrioid", "Myometrial invasion", "Ca125", "Weakened Ecadherin", "Thrombocyte", "Positive cytology", "Stage I vs II-IV"))

ShapelyGraphicFinnishEarlyRecurPOLEtidymodels

### RUN TOGETHER:
pdf("ShapelyGraphicFinnishEarlyRecurPOLEtidymodels.pdf") 
# 2. Create a plot
plot(ShapelyGraphicFinnishEarlyRecurPOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ShapelyGraphicFinnishEarlyRecurPOLEtidymodels.png") 
# 2. Create a plot
plot(ShapelyGraphicFinnishEarlyRecurPOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

ShapelyGraphicFinnishEarlyRecurPOLEtidymodels
```

```{r}
ShapelyGraphicFinnishLateRecurPOLEtidymodels <- sv_importance(svFinnishRecurPOLEtidymodels$LateRelpase , kind = "beeswarm", max_display = 10) + ylab("Feature") + xlab("SHAP value (impact on model output)") + ggtitle("Feature impact for Late relapse") + theme(axis.text.y = element_text(size = 10), plot.title = element_text(size=12),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA), text=element_text(color="black"),axis.text=element_text(color="black")) + scale_colour_gradient(
    low = "blue", high = "red",
    breaks = c(0, 1), labels = c("Low", "High"))+ scale_y_discrete(labels = c("ASA Score","ARID1A","Leucocyte","Hemoglobin","Age","Thrombocye","PR","LVSI", "Tumor size","Normal Ecadherin")) 

ShapelyGraphicFinnishLateRecurPOLEtidymodels

### RUN TOGETHER:
pdf("ShapelyGraphicFinnishLateRecurPOLEtidymodels.pdf") 
# 2. Create a plot
plot(ShapelyGraphicFinnishLateRecurPOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ShapelyGraphicFinnishLateRecurPOLEtidymodels.png") 
# 2. Create a plot
plot(ShapelyGraphicFinnishLateRecurPOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

ShapelyGraphicFinnishLateRecurPOLEtidymodels
```

```{r}
ShapelyGraphicFinnishNoRecurPOLEtidymodels <- sv_importance(svFinnishRecurPOLEtidymodels$NoRelapse, kind = "beeswarm", max_display = 10) + ylab("Feature") + xlab("SHAP value (impact on model output)") + ggtitle("Feature impact for no relapse") + theme(axis.text.y = element_text(size = 10), plot.title = element_text(size=12),
panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA), text=element_text(color="black"),axis.text=element_text(color="black")) + scale_colour_gradient(
    low = "blue", high = "red",
    breaks = c(0, 1), labels = c("Low", "High")) + scale_y_discrete(labels = c("Thrombocyte", "Myometrial invasion",  "ARID1A", "LVSI", "Leucocyte", "PR", "Positive cytology","Normal Ecadherin", "Tumor size", "Stage I vs II-IV"))


ShapelyGraphicFinnishNoRecurPOLEtidymodels

### RUN TOGETHER:
pdf("ShapelyGraphicFinnishNoRecurPOLEtidymodels.pdf") 
# 2. Create a plot
plot(ShapelyGraphicFinnishNoRecurPOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ShapelyGraphicFinnishNoRecurPOLEtidymodels.png") 
# 2. Create a plot
plot(ShapelyGraphicFinnishNoRecurPOLEtidymodels)
# Close the pdf file
dev.off() 
### UNTIL HERE

ShapelyGraphicFinnishNoRecurPOLEtidymodels  
```

#### Confusion matrix creation:

```{r}
#This code generates the confusion matrix shown in Figure 4B of the manuscript

cmPOLE <- confusionMatrix(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

cm_tablePOLE <- as.data.frame(cmPOLE$table)

ConfusionMatrixFigureRelapseRiskPOLE <- ggplot(cm_tablePOLE, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Freq), color = "black", size = 4) +
  scale_fill_gradient(low = "darkslategray2", high = "darkkhaki") +
  labs(x = element_blank(),y = "Predicted class",
    fill = "Frequency"
  ) +
  theme_minimal() +
  theme(axis.text = element_text(size = 10,color="black"),
    axis.title = element_text(size = 12),
    legend.position = "right", text=element_text(color="black")
  ) + scale_x_discrete(labels= c("No relapse", "Early relapse", "Late relapse")) +
   scale_y_discrete(labels=c("No relapse", "Early relapse", "Late relapse"))

ConfusionMatrixFigureRelapseRiskPOLE

### RUN TOGETHER:
pdf("ConfusionMatrixFigureRelapseRiskPOLE.pdf") 
# 2. Create a plot
plot(ConfusionMatrixFigureRelapseRiskPOLE)
# Close the pdf file
dev.off() 
### UNTIL HERE


### RUN TOGETHER:
png("ConfusionMatrixFigureRelapseRiskPOLE.png") 
# 2. Create a plot
plot(ConfusionMatrixFigureRelapseRiskPOLE)
# Close the pdf file
dev.off() 
### UNTIL HERE

ConfusionMatrixFigureRelapseRiskPOLE
```

##### Extract all metrics:

###### TP53 + MMRd::

```{r}
#The code in this sections extracts the metrics values for all the models and puts it into a single table, which is Supplementary Table 4

predictionsRecurTP53MMRd <- predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels)

probabilitiesRecurTP53MMRd <- predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels, type = "prob")

Confusion_matrixRecurTP53MMRd <- confusionMatrix(predictionsRecurTP53MMRd, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurTP53MMRd <- multiclass.roc(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk, probabilitiesRecurTP53MMRd[, 2])  
auc_valueRecurTP53MMRd <- auc(roc_curveRecurTP53MMRd)

# Obtain metrics
accuracyRecurTP53MMRd  <- Confusion_matrixRecurTP53MMRd$overall['Accuracy']

kappaRecurTP53MMRd  <- Confusion_matrixRecurTP53MMRd$overall['Kappa']

f1RecurTP53MMRd  <-  MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

sensitivityRecurTP53MMRd  <- MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurTP53MMRd  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTP53MMRd , 3),
    round(f1RecurTP53MMRd , 3),
    round(sensitivityRecurTP53MMRd , 3),
    round(auc_valueRecurTP53MMRd , 3)
  )
)

# Print metrics table
print(metricsRecurTP53MMRd)

metricsRecurTP53MMRdTranspose <- as.data.frame(t(metricsRecurTP53MMRd))

colnames(metricsRecurTP53MMRdTranspose) <- metricsRecurTP53MMRdTranspose[1,]

metricsRecurTP53MMRdTranspose <- metricsRecurTP53MMRdTranspose[-1,]
```

###### TP53 + MMRd - Rf::

```{r}
TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodelsF1.rds")

predictionsRecurTP53MMRdRf <- predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels)

probabilitiesRecurTP53MMRdRf <- predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels, type = "prob")

# Calculate confusion matrix and metrics
confusion_matrixRecurTP53MMRdRf <- confusionMatrix(predictionsRecurTP53MMRdRf, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Calculate AUC
roc_curveRecurTP53MMRdRf <- multiclass.roc(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk, probabilitiesRecurTP53MMRdRf[, 2]) 
auc_valueRecurTP53MMRdRf <- auc(roc_curveRecurTP53MMRdRf)

# Obtain metrics
accuracyRecurTP53MMRdRf  <- confusion_matrixRecurTP53MMRdRf$overall['Accuracy']

kappaRecurTP53MMRdRf  <- confusion_matrixRecurTP53MMRdRf$overall['Kappa']

f1RecurTP53MMRdRf  <-  MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

SensitivityRecurTP53MMRdRf  <- MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Create metrics table
metricsRecurTP53MMRdRf  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTP53MMRdRf , 3),
    round(f1RecurTP53MMRdRf , 3),
    round(SensitivityRecurTP53MMRdRf , 3),
    round(auc_valueRecurTP53MMRdRf , 3)
  )
)

print(metricsRecurTP53MMRdRf)

metricsRecurTP53MMRdTransposeRf <- as.data.frame(t(metricsRecurTP53MMRdRf))

colnames(metricsRecurTP53MMRdTransposeRf) <- metricsRecurTP53MMRdTransposeRf[1,]

metricsRecurTP53MMRdTransposeRf <- metricsRecurTP53MMRdTransposeRf[-1,]
```

###### TP53 + MMRd - KNN::

```{r}
TP53MMRdRiskOfRecurrenceDef.KNN.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.KNN.cv.10.tuneLengthROCtidymodelsF1.rds")

predictionsRecurTP53MMRdKNN <- predict(TP53MMRdRiskOfRecurrenceDef.KNN.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels)

probabilitiesRecurTP53MMRdKNN <- predict(TP53MMRdRiskOfRecurrenceDef.KNN.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels, type = "prob")

# Calculate confusion matrix and metrics:
confusion_matrixRecurTP53MMRdKNN <- confusionMatrix(predictionsRecurTP53MMRdKNN, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Calculate AUC 
roc_curveRecurTP53MMRdKNN <- multiclass.roc(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk, probabilitiesRecurTP53MMRdKNN[, 2]) 
auc_valueRecurTP53MMRdKNN <- auc(roc_curveRecurTP53MMRdKNN)

# Obtain the metrics
accuracyRecurTP53MMRdKNN  <- confusion_matrixRecurTP53MMRdKNN$overall['Accuracy']

kappaRecurTP53MMRdKNN  <- confusion_matrixRecurTP53MMRdKNN$overall['Kappa']

f1RecurTP53MMRdKNN  <-  MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.KNN.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

SensitivityRecurTP53MMRdKNN  <- MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.KNN.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurTP53MMRdKNN  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTP53MMRdKNN , 3),
    round(f1RecurTP53MMRdKNN , 3),
    round(SensitivityRecurTP53MMRdKNN , 3),
    round(auc_valueRecurTP53MMRdKNN , 3)
  )
)

print(metricsRecurTP53MMRdKNN)

metricsRecurTP53MMRdTransposeKNN <- as.data.frame(t(metricsRecurTP53MMRdKNN))

colnames(metricsRecurTP53MMRdTransposeKNN) <- metricsRecurTP53MMRdTransposeKNN[1,]

metricsRecurTP53MMRdTransposeKNN <- metricsRecurTP53MMRdTransposeKNN[-1,]
```

###### TP53 + MMRd - SVM::

```{r}
TP53MMRdRiskOfRecurrenceDef.SVM.cv.10.tuneLengthROCtidymodels <- readRDS(file = "TP53MMRdRiskOfRecurrenceDef.SVM.cv.10.tuneLengthROCtidymodelsF1.rds")

predictionsRecurTP53MMRdSVM <- predict(TP53MMRdRiskOfRecurrenceDef.SVM.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels)

probabilitiesRecurTP53MMRdSVM <- predict(TP53MMRdRiskOfRecurrenceDef.SVM.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurTP53MMRdSVM <- confusionMatrix(predictionsRecurTP53MMRdSVM, opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Calculate AUC
roc_curveRecurTP53MMRdSVM <- multiclass.roc(opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk, probabilitiesRecurTP53MMRdSVM[, 2]) 
auc_valueRecurTP53MMRdSVM <- auc(roc_curveRecurTP53MMRdSVM)

# Obtain the metrics
accuracyRecurTP53MMRdSVM  <- confusion_matrixRecurTP53MMRdSVM$overall['Accuracy']

kappaRecurTP53MMRdSVM  <- confusion_matrixRecurTP53MMRdSVM$overall['Kappa']

f1RecurTP53MMRdSVM  <-  MLmetrics::F1_Score(predict(TP53MMRdRiskOfRecurrenceDef.SVM.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

SensitivityRecurTP53MMRdSVM  <- MLmetrics::Sensitivity(predict(TP53MMRdRiskOfRecurrenceDef.SVM.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels),opt.Datos.Test.FinnishRecurtp53MMRdROCtidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurTP53MMRdSVM  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTP53MMRdSVM , 3),
    round(f1RecurTP53MMRdSVM , 3),
    round(SensitivityRecurTP53MMRdSVM , 3),
    round(auc_valueRecurTP53MMRdSVM , 3)
  )
)

# Print the metrics table
print(metricsRecurTP53MMRdSVM)

metricsRecurTP53MMRdTransposeSVM <- as.data.frame(t(metricsRecurTP53MMRdSVM))

colnames(metricsRecurTP53MMRdTransposeSVM) <- metricsRecurTP53MMRdTransposeSVM[1,]

metricsRecurTP53MMRdTransposeSVM <- metricsRecurTP53MMRdTransposeSVM[-1,]
```


###### Traditional:

```{r}
#TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels
#gbmFit2Traditionaltidymodels

predictionssRecurTraditional <- predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels)

probabilitiesRecurTraditional <- predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurTraditional <- confusionMatrix(predictionsRecurTraditional, opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Calculate AUC
roc_curveRecurTraditional <- multiclass.roc(opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk, probabilitiesRecurTraditional[, 2])  
auc_valueRecurTraditional <- auc(roc_curveRecurTraditional)

# Obtain the metrics
accuracyRecurTraditional  <- confusion_matrixRecurTraditional$overall['Accuracy']

kappaRecurTraditional  <- confusion_matrixRecurTraditional$overall['Kappa']

f1RecurTraditional  <-  MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

sensitivityRecurTraditional  <- MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurTraditional  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTraditional , 3),
    round(f1RecurTraditional , 3),
    round(sensitivityRecurTraditional , 3),
    round(auc_valueRecurTraditional , 3)
  )
)

# Print the metrics table
print(metricsRecurTraditional )

metricsRecurTraditionalTranspose <- as.data.frame(t(metricsRecurTraditional))

colnames(metricsRecurTraditionalTranspose) <- metricsRecurTraditionalTranspose[1,]

metricsRecurTraditionalTranspose <- metricsRecurTraditionalTranspose[-1,]
```

###### Traditional - Rf:

```{r}
predictionsRecurTraditionalRf <- predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels)

probabilitiesRecurTraditionalRf <- predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurTraditionalRf <- confusionMatrix(predictionsRecurTraditionalRf, opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Calculate AUC 
roc_curveRecurTraditionalRf <- multiclass.roc(opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk, probabilitiesRecurTraditionalRf[, 2])  
auc_valueRecurTraditionalRf <- auc(roc_curveRecurTraditionalRf)

# Obtain the metrics
accuracyRecurTraditionalRf  <- confusion_matrixRecurTraditionalRf$overall['Accuracy']

kappaRecurTraditionalRf  <- confusion_matrixRecurTraditionalRf$overall['Kappa']

f1RecurTraditionalRf  <-  MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

sensitivityRecurTraditionalRf  <- MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Create a table with all the metrics
metricsRecurTraditionalRf  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTraditionalRf , 3),
    round(f1RecurTraditionalRf , 3),
    round(sensitivityRecurTraditionalRf , 3),
    round(auc_valueRecurTraditionalRf , 3)
  )
)

# Show the metrics table
print(metricsRecurTraditionalRf )

metricsRecurTraditionalRfTranspose <- as.data.frame(t(metricsRecurTraditionalRf))

colnames(metricsRecurTraditionalRfTranspose) <- metricsRecurTraditionalRfTranspose[1,]

metricsRecurTraditionalRfTranspose <- metricsRecurTraditionalRfTranspose[-1,]
```

###### Traditional - KNN:

```{r}
predictionsRecurTraditionalKNN <- predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels)

probabilitiesRecurTraditionalKNN <- predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurTraditionalKNN <- confusionMatrix(predictionsRecurTraditionalKNN, opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Calculate AUC 
roc_curveRecurTraditionalKNN <- multiclass.roc(opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk, probabilitiesRecurTraditionalKNN[, 2]) 
auc_valueRecurTraditionalKNN <- auc(roc_curveRecurTraditionalKNN)

# Obtain the metrics
accuracyRecurTraditionalKNN  <- confusion_matrixRecurTraditionalKNN$overall['Accuracy']

kappaRecurTraditionalKNN  <- confusion_matrixRecurTraditionalKNN$overall['Kappa']

f1RecurTraditionalKNN  <-  MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

sensitivityRecurTraditionalKNN  <- MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurTraditionalKNN  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTraditionalKNN , 3),
    round(f1RecurTraditionalKNN , 3),
    round(sensitivityRecurTraditionalKNN , 3),
    round(auc_valueRecurTraditionalKNN , 3)
  )
)

print(metricsRecurTraditionalKNN )

metricsRecurTraditionalKNNTranspose <- as.data.frame(t(metricsRecurTraditionalKNN))

colnames(metricsRecurTraditionalKNNTranspose) <- metricsRecurTraditionalKNNTranspose[1,]

metricsRecurTraditionalKNNTranspose <- metricsRecurTraditionalKNNTranspose[-1,]
```

###### Traditional - SVM:

```{r}
predictionssRecurTraditionalSVM <- predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels)

probabilitiesRecurTraditionalSVM <- predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurTraditionaltidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurTraditionalSVM <- confusionMatrix(predictionsRecurTraditionalSVM, opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurTraditionalSVM <- multiclass.roc(opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk, probabilitiesRecurTraditionalSVM[, 2]) 
auc_valueRecurTraditionalSVM <- auc(roc_curveRecurTraditionalSVM)

# Obtain the metrics
accuracyRecurTraditionalSVM  <- confusion_matrixRecurTraditionalSVM$overall['Accuracy']

kappaRecurTraditionalSVM  <- confusion_matrixRecurTraditionalSVM$overall['Kappa']

f1RecurTraditionalSVM  <-  MLmetrics::F1_Score(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

sensitivityRecurTraditionalSVM  <- MLmetrics::Sensitivity(predict(TraditionalRiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurTraditionaltidymodels),opt.Datos.Test.FinnishRecurTraditionaltidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurTraditionalSVM  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurTraditionalSVM , 3),
    round(f1RecurTraditionalSVM , 3),
    round(sensitivityRecurTraditionalSVM , 3),
    round(auc_valueRecurTraditionalSVM , 3)
  )
)

print(metricsRecurTraditionalSVM )

metricsRecurTraditionalSVMTranspose <- as.data.frame(t(metricsRecurTraditionalSVM))

colnames(metricsRecurTraditionalSVMTranspose) <- metricsRecurTraditionalSVMTranspose[1,]

metricsRecurTraditionalSVMTranspose <- metricsRecurTraditionalSVMTranspose[-1,]
```

###### ESGO:

```{r}
predictionsRecurESGO <- predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels)

probabilitiesRecurESGO <- predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurESGO <- confusionMatrix(predictionsRecurESGO, opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurESGO <- multiclass.roc(opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk, probabilitiesRecurESGO[, 2])  
auc_valueRecurESGO <- auc(roc_curveRecurESGO)

# Obtain the metrics
accuracyRecurESGO  <- confusion_matrixRecurESGO$overall['Accuracy']

kappaRecurESGO  <- confusion_matrixRecurESGO$overall['Kappa']

f1RecurESGO  <-  MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

sensitivityRecurESGO  <- MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Create te thable with all metrics
metricsRecurESGO  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurESGO , 3),
    round(f1RecurESGO , 3),
    round(sensitivityRecurESGO , 3),
    round(auc_valueRecurESGO , 3)
  )
)

print(metricsRecurESGO)

metricsRecurESGOTranspose <- as.data.frame(t(metricsRecurESGO))

colnames(metricsRecurESGOTranspose) <- metricsRecurESGOTranspose[1,]

metricsRecurESGOTranspose <- metricsRecurESGOTranspose[-1,]
```

###### ESGO - Rf:

```{r}
predictionsRecurESGORf <- predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels)

probabilitiesRecurESGORf <- predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels, type = "prob")

# Calculate confusion matrix and metrics
confusion_matrixRecurESGORf <- confusionMatrix(predictionsRecurESGORf, opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Calculate ROC AUC 
roc_curveRecurESGORf <- multiclass.roc(opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk, probabilitiesRecurESGORf[, 2])
auc_valueRecurESGORf <- auc(roc_curveRecurESGORf)

# Obtain the metrics
accuracyRecurESGORf  <- confusion_matrixRecurESGORf$overall['Accuracy']

kappaRecurESGORf  <- confusion_matrixRecurESGORf$overall['Kappa']

f1RecurESGORf  <-  MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

sensitivityRecurESGORf  <- MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Create a table with all the metrics
metricsRecurESGORf  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurESGORf , 3),
    round(f1RecurESGORf , 3),
    round(sensitivityRecurESGORf , 3),
    round(auc_valueRecurESGORf , 3)
  )
)

print(metricsRecurESGORf)

metricsRecurESGORfTranspose <- as.data.frame(t(metricsRecurESGORf))

colnames(metricsRecurESGORfTranspose) <- metricsRecurESGORfTranspose[1,]

metricsRecurESGORfTranspose <- metricsRecurESGORfTranspose[-1,]
```

###### ESGO - KNN:

```{r}
predictionsRecurESGOKNN <- predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels)

probabilitiesRecurESGOKNN <- predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurESGOKNN <- confusionMatrix(predictionsRecurESGOKNN, opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Calculate ROC AUC 
roc_curveRecurESGOKNN <- multiclass.roc(opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk, probabilitiesRecurESGOKNN[, 2]) 
auc_valueRecurESGOKNN <- auc(roc_curveRecurESGOKNN)

# Obtain the metrics
accuracyRecurESGOKNN  <- confusion_matrixRecurESGOKNN$overall['Accuracy']

kappaRecurESGOKNN  <- confusion_matrixRecurESGOKNN$overall['Kappa']

f1RecurESGOKNN  <-  MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

sensitivityRecurESGOKNN  <- MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Create the table with all metrics
metricsRecurESGOKNN  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurESGOKNN , 3),
    round(f1RecurESGOKNN , 3),
    round(sensitivityRecurESGOKNN , 3),
    round(auc_valueRecurESGOKNN , 3)
  )
)

print(metricsRecurESGOKNN)

metricsRecurESGOKNNTranspose <- as.data.frame(t(metricsRecurESGOKNN))

colnames(metricsRecurESGOKNNTranspose) <- metricsRecurESGOKNNTranspose[1,]

metricsRecurESGOKNNTranspose <- metricsRecurESGOKNNTranspose[-1,]
```

###### ESGO - SVM:

```{r}
predictionsRecurESGOSVM <- predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels)

probabilitiesRecurESGOSVM <- predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurESGOtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurESGOSVM <- confusionMatrix(predictionsRecurESGOSVM, opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurESGOSVM <- multiclass.roc(opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk, probabilitiesRecurESGOSVM[, 2])  
auc_valueRecurESGOSVM <- auc(roc_curveRecurESGOSVM)

# Obtain the metrics
accuracyRecurESGOSVM  <- confusion_matrixRecurESGOSVM$overall['Accuracy']

kappaRecurESGOSVM  <- confusion_matrixRecurESGOSVM$overall['Kappa']

f1RecurESGOSVM  <-  MLmetrics::F1_Score(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

sensitivityRecurESGOSVM  <- MLmetrics::Sensitivity(predict(ESGORiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurESGOtidymodels),opt.Datos.Test.FinnishRecurESGOtidymodels$recurrence_risk)

# Create a table with all the metrics
metricsRecurESGOSVM  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurESGOSVM , 3),
    round(f1RecurESGOSVM , 3),
    round(sensitivityRecurESGOSVM , 3),
    round(auc_valueRecurESGOSVM , 3)
  )
)

print(metricsRecurESGOSVM)

metricsRecurESGOSVMTranspose <- as.data.frame(t(metricsRecurESGOSVM))

colnames(metricsRecurESGOSVMTranspose) <- metricsRecurESGOSVMTranspose[1,]

metricsRecurESGOSVMTranspose <- metricsRecurESGOSVMTranspose[-1,]
```

###### POLE:

```{r}
predictionsRecurPOLE <- predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels)

probabilitiesRecurPOLE <- predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurPOLE <- confusionMatrix(predictionsRecurPOLE, opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurPOLE <- multiclass.roc(opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk, probabilitiesRecurPOLE[, 2])
auc_valueRecurPOLE <- auc(roc_curveRecurPOLE)

# Obtain the metrics
accuracyRecurPOLE  <- confusion_matrixRecurPOLE$overall['Accuracy']

kappaRecurPOLE  <- confusion_matrixRecurPOLE$overall['Kappa']

f1RecurPOLE  <-  MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

sensitivityRecurPOLE  <- MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.gbm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Create the table with all metrics
metricsRecurPOLE  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurPOLE , 3),
    round(f1RecurPOLE , 3),
    round(sensitivityRecurPOLE , 3),
    round(auc_valueRecurPOLE , 3)
  )
)

print(metricsRecurPOLE )

metricsRecurPOLETranspose <- as.data.frame(t(metricsRecurPOLE))

colnames(metricsRecurPOLETranspose) <- metricsRecurPOLETranspose[1,]

metricsRecurPOLETranspose <- metricsRecurPOLETranspose[-1,]
```

###### POLE - Rf:

```{r}
predictionsRecurPOLERf <- predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels)

probabilitiesRecurPOLERf <- predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurPOLERf <- confusionMatrix(predictionsRecurPOLERf, opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurPOLERf <- multiclass.roc(opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk, probabilitiesRecurPOLERf[, 2]) 
auc_valueRecurPOLERf <- auc(roc_curveRecurPOLERf)

# Obtain all metrics
accuracyRecurPOLERf  <- confusion_matrixRecurPOLERf$overall['Accuracy']

kappaRecurPOLERf  <- confusion_matrixRecurPOLERf$overall['Kappa']

f1RecurPOLERf  <-  MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

sensitivityRecurPOLERf  <- MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.rf.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurPOLERf  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurPOLERf , 3),
    round(f1RecurPOLERf , 3),
    round(sensitivityRecurPOLERf , 3),
    round(auc_valueRecurPOLERf , 3)
  )
)

print(metricsRecurPOLERf )

metricsRecurPOLERfTranspose <- as.data.frame(t(metricsRecurPOLERf))

colnames(metricsRecurPOLERfTranspose) <- metricsRecurPOLERfTranspose[1,]

metricsRecurPOLERfTranspose <- metricsRecurPOLERfTranspose[-1,]
```

###### POLE - KNN:

```{r}
predictionsRecurPOLEKNN <- predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels)

probabilitiesRecurPOLEKNN <- predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels, type = "prob")

# Calculate confusion matrix and metrics
confusion_matrixRecurPOLEKNN <- confusionMatrix(predictionsRecurPOLEKNN, opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Calculate ROC AUC 
roc_curveRecurPOLEKNN <- multiclass.roc(opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk, probabilitiesRecurPOLEKNN[, 2]) 
auc_valueRecurPOLEKNN <- auc(roc_curveRecurPOLEKNN)

# Obtain the metrics
accuracyRecurPOLEKNN  <- confusion_matrixRecurPOLEKNN$overall['Accuracy']

kappaRecurPOLEKNN  <- confusion_matrixRecurPOLEKNN$overall['Kappa']

f1RecurPOLEKNN  <-  MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

sensitivityRecurPOLEKNN  <- MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.knn.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurPOLEKNN  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurPOLEKNN , 3),
    round(f1RecurPOLEKNN , 3),
    round(sensitivityRecurPOLEKNN , 3),
    round(auc_valueRecurPOLEKNN , 3)
  )
)

print(metricsRecurPOLEKNN )

metricsRecurPOLEKNNTranspose <- as.data.frame(t(metricsRecurPOLEKNN))

colnames(metricsRecurPOLEKNNTranspose) <- metricsRecurPOLEKNNTranspose[1,]

metricsRecurPOLEKNNTranspose <- metricsRecurPOLEKNNTranspose[-1,]
```

###### POLE - SVM:

```{r}
predictionsRecurPOLESVM <- predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels)

probabilitiesRecurPOLESVM <- predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels, opt.Datos.Test.FinnishRecurPOLEtidymodels, type = "prob")

# Calculate the confusion matrix and metrics
confusion_matrixRecurPOLESVM <- confusionMatrix(predictionsRecurPOLESVM, opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Calculate ROC AUC
roc_curveRecurPOLESVM <- multiclass.roc(opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk, probabilitiesRecurPOLESVM[, 2]) 
auc_valueRecurPOLESVM <- auc(roc_curveRecurPOLESVM)

# Obtain the metrics
accuracyRecurPOLESVM  <- confusion_matrixRecurPOLESVM$overall['Accuracy']

kappaRecurPOLESVM  <- confusion_matrixRecurPOLESVM$overall['Kappa']

f1RecurPOLESVM  <-  MLmetrics::F1_Score(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

sensitivityRecurPOLESVM  <- MLmetrics::Sensitivity(predict(POLERiskOfRecurrenceDef.svm.cv.10.tuneLengthROCtidymodels,opt.Datos.Test.FinnishRecurPOLEtidymodels),opt.Datos.Test.FinnishRecurPOLEtidymodels$recurrence_risk)

# Create a table with all metrics
metricsRecurPOLESVM  <- data.frame(
  Metric = c("Accuracy", "F1 Score","Sensitivity", "AUC"),
  Value = c(
    round(accuracyRecurPOLESVM , 3),
    round(f1RecurPOLESVM , 3),
    round(sensitivityRecurPOLESVM , 3),
    round(auc_valueRecurPOLESVM , 3)
  )
)

print(metricsRecurPOLESVM )

metricsRecurPOLESVMTranspose <- as.data.frame(t(metricsRecurPOLESVM))

colnames(metricsRecurPOLESVMTranspose) <- metricsRecurPOLESVMTranspose[1,]

metricsRecurPOLESVMTranspose <- metricsRecurPOLESVMTranspose[-1,]
```

###### Combined metrics:

```{r}
TotalMetricssRecurRiskTP53MMRd <- rbind(metricsRecurTP53MMRdTranspose, metricsRecurTP53MMRdTransposeRf[1,], metricsRecurTP53MMRdTransposeKNN[1,],metricsRecurTP53MMRdTransposeSVM[1,])

row.names(TotalMetricssRecurRiskTP53MMRd) <- c("TP53 + MMRd - GBM", "TP53 + MMRd - RF", "TP53 + MMRd - KNN", "TP53 + MMRd - SVM")

#write.csv(TotalMetricssRecurRiskTP53MMRd, "TotalMetricssRecurRiskTP53MMRd.csv")
```

```{r}
TotalMetricssRecurRiskTraditional <- rbind(metricsRecurTraditionalTranspose, metricsRecurTraditionalRfTranspose[1,], metricsRecurTraditionalKNNTranspose[1,],metricsRecurTraditionalSVMTranspose[1,])

row.names(TotalMetricssRecurRiskTraditional) <- c("Traditional - GBM", "Traditional - RF", "Traditional - KNN", "Traditional - SVM")

#write.csv(TotalMetricssRecurRiskTraditional, "TotalMetricssRecurRiskTraditional.csv")
```

```{r}
TotalMetricsRecurRiskESGO <- rbind(metricsRecurESGOTranspose, metricsRecurESGORfTranspose[1,], metricsRecurESGOKNNTranspose[1,],metricsRecurESGOSVMTranspose[1,])

row.names(TotalMetricsRecurRiskESGO) <- c("ESGO - GBM", "ESGO - RF", "ESGO - KNN", "ESGO - SVM")

#write.csv(TotalMetricsRecurRiskESGO, "TotalMetricsRecurRiskESGO.csv")
```

```{r}
TotalMetricsRecurRiskPOLE <- rbind(metricsRecurPOLETranspose, metricsRecurPOLERfTranspose[1,], metricsRecurPOLEKNNTranspose[1,],metricsRecurPOLESVMTranspose[1,])

row.names(TotalMetricsRecurRiskPOLE) <- c("POLE - GBM", "POLE - RF", "POLE - KNN", "POLE - SVM")

#write.csv(TotalMetricsRecurRiskPOLE, "TotalMetricsRecurRiskPOLE.csv")
```

```{r}
TotalMetricsRecurRisk <- rbind(TotalMetricsRecurRiskTP53MMRd,TotalMetricsRecurRiskTraditional,TotalMetricsRecurRiskESGO,TotalMetricsRecurRiskPOLE)

#write.csv(TotalMetricsRecurRisk, "TotalMetricsRecurRisk.csv")  #This is the Table in Supplementary table 4
```

### Heatmap

```{r}
TotalMetricsRecurRiskImputed <- TotalMetricsRecurRisk

TotalMetricsRecurRiskImputed[12,2] <- 0

TotalMetricsRecurRiskImputed2 <- sapply(TotalMetricsRecurRiskImputed, as.numeric)

row.names(TotalMetricsRecurRiskImputed2) <- row.names(TotalMetricsRecurRiskImputed)
```

```{r}
TotalMetricsRecurRiskImputed3 <- as.data.frame(TotalMetricsRecurRiskImputed2)

TotalMetricsRecurRiskImputed3$Sample <- rownames(TotalMetricsRecurRiskImputed3)

library(reshape2)

df_long <- melt(TotalMetricsRecurRiskImputed3, id.vars = "Sample")

DefinitiveHeatmapMetrics <-  ggplot(df_long, aes(x = variable, y = Sample, fill = value)) +
  geom_tile() +
  geom_text(aes(label = round(value, 3)), size = 3, color="white") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +  
  theme_minimal() +
  labs(x = element_blank(), y = element_blank(), fill = "Value") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
  text=element_text(color="black"),axis.text=element_text(color="black"))

DefinitiveHeatmapMetrics

### RUN TOGETHER:
png("HeatmapForMetrics.png") 
# 2. Create a plot
plot(DefinitiveHeatmapMetrics)
# Close the png file
dev.off() 
###

### RUN TOGETHER:
pdf("HeatmapForMetrics.pdf") 
# 2. Create a plot
plot(DefinitiveHeatmapMetrics)
# Close the png file
dev.off() 
###

DefinitiveHeatmapMetrics  #After creating the supplementary table, this heatmap can be created, that is the figure represented in Figure 1A.
```

#### Venn diagrams:

```{r}
#The following code is used to extract the different features selected in every recursive feature elimination process as well as to create a Venn diagram representing the feature intersections among models

library("ggVennDiagram")

VennDiagramRisk <- ggVennDiagram(list(ImportanceFinnishRecurTP53MMRdTidymodelsSorted$`row.names(ImportanceFinnishRecurTP53MMRdTidymodels)`, ImportanceFinnishRecurTraditionalTidymodelsSorted$`row.names(ImportanceFinnishRecurTraditionalTidymodels)`, ImportanceFinnishRecurESGOTidymodelsSorted$`row.names(ImportanceFinnishRecurESGOTidymodels)`, ImportanceFinnishRecurPOLETidymodelsSorted$`row.names(ImportanceFinnishRecurPOLETidymodels)`),  label_alpha = 0,
  category.names = c("TP53 + MMRd","Traditional", "ESGO","POLE"), set_color = c("black","red","green","orange")
  ) +
  ggplot2::scale_fill_distiller(palette = "RdBu") +
  scale_x_continuous(expand = expansion(mult = .2)) +
  scale_fill_gradient(low = "lightblue", high = "steelblue4")

VennDiagramRisk

### RUN TOGETHER:
png("VennDiagramRisk.png") 
# 2. Create a plot
plot(VennDiagramRisk)
# Close the png file
dev.off() 
###

### RUN TOGETHER:
pdf("VennDiagramRisk.pdf") 
# 2. Create a plot
plot(VennDiagramRisk)
# Close the png file
dev.off() 
###

VennDiagramRisk   #This is the Venn Diagram represented in Figure 1B of the manuscript
```

```{r}
venn_data <- process_data(Venn(list(ImportanceFinnishRecurTP53MMRdTidymodelsSorted$`row.names(ImportanceFinnishRecurTP53MMRdTidymodels)`, ImportanceFinnishRecurTraditionalTidymodelsSorted$`row.names(ImportanceFinnishRecurTraditionalTidymodels)`, ImportanceFinnishRecurESGOTidymodelsSorted$`row.names(ImportanceFinnishRecurESGOTidymodels)`, ImportanceFinnishRecurPOLETidymodelsSorted$`row.names(ImportanceFinnishRecurPOLETidymodels)`)`)))

# View all intersections
intersections <- venn_data$regionData
```

```{r}
intersectionsdataframe <- as.data.frame(intersections)

intersectionsdataframe$item <- sapply(intersectionsdataframe$item, function(x) paste(x, collapse = ", "))

#write.csv(intersectionsdataframe, "VennDiagramData.csv", row.names = FALSE) #This is Supplementary Table 5
```

















